Siviglia.Utils.buildClass(
	{
		context: 'Siviglia.types',
		classes: {
			DateTimeRelative: {
				inherits: 'DateTime',
				constants: {
					PERIODS: {
						"default": ["years", "months", "days", "hours", "minutes", "seconds"],
						"en-US": ["years", "months", "days", "hours", "minutes", "seconds"],
						"es-ES": ["años", "meses", "días", "horas", "minutos", "segundos"],
					},
					SIGN: ["+", "-"],
				},
				methods: {
					getValue: function() {
						var delta = this.delta;
						if (delta === undefined)
							return this.DateTime$getValue();

						return this.DateTime$getValue();
					},
					setDelta: function(sign, value, period) {
						var exp = value + ".." + Siviglia.types.DateTimeRelative.PERIODS["default"][period];
						if (sign === 1) {
							exp += ".after(date)";
						} else {
							exp += ".before(date)";
						}
						return this.delta = exp;
					},
					_setValue: function(val, validationMode) {
						debugger;
						console.log(val);
					},
					getDate: function(sign, value, period) {
						var date = new Date(this.getValue());
						delta = this.setDelta(sign, value, period);
						date = eval(delta);
						return new Siviglia.types.DateTime("", [], null, date).getValue();
					},
				}
			},
			DateTimeInterval: {
				inherits: 'Container',
				constants: {
					PERIODS: {
						"default": ["years", "months", "days", "hours", "minutes", "seconds"],
						"en-US": ["years", "months", "days", "hours", "minutes", "seconds"],
						"es-ES": ["años", "meses", "días", "horas", "minutos", "segundos"],
					},
				},
				construct: function(name, def, parentType, val, validationMode) {
					var stdDef = {
						'TYPE': "DateTimeInterval",
						'FIELDS': {
							'years': {
								'TYPE': 'Integer',
								'LABEL': 'Años',
								'DEFAULT': 0,
								'MIN': 0
							},
							'months': {
								'TYPE': 'Integer',
								'LABEL': 'Meses',
								'DEFAULT': 0,
								'MIN': 0
							},
							'days': {
								'TYPE': 'Integer',
								'LABEL': 'Días',
								'DEFAULT': 0,
								'MIN': 0
							},
							'hours': {
								'TYPE': 'Integer',
								'LABEL': 'Horas',
								'DEFAULT': 0,
								'MIN': 0
							},
							'minutes': {
								'TYPE': 'Integer',
								'LABEL': 'Minutos',
								'DEFAULT': 0,
								'MIN': 0
							},
							'seconds': {
								'TYPE': 'Integer',
								'LABEL': 'Segundos',
								'DEFAULT': 0,
								'MIN': 0
							}
						}
					};
					var fullDef = this.__overrideDefinition(def, stdDef);
					this.Container(name, fullDef, parentType, val, validationMode);
				},
				methods: {
					isValid: function() {
						var sum = 0;
						for (field in this.__fields) {
							sum += this.__fields[field].getValue();
						}
						return sum;
					}
				}
			},
			DateTimeRange: {
				inherits: 'Container',
				construct: function(name, def, parentType, val, validationMode) {
					var stdDef = {
						TYPE: "DateTimeRange",
						FIELDS: {
							startDate: {
								TYPE: "DateTime",
								LABEL: "Fecha de inicio"
							},
							endDate: {
								TYPE: "DateTimeRelative",
								LABEL: "Fecha de fin"
							},
							interval: {
								TYPE: "DateTimeInterval",
								LABEL: "Intervalo"
							}
						},
					};
					var fullDef = this.__overrideDefinition(def, stdDef);
					this.Container(name, fullDef, parentType, val, validationMode);
				},
				methods: {
					getValue: function() {
						var def = {
							TYPE: 'Array',
							VALUETYPE: {
								TYPE: 'String'
							}
						};
						var list = [];
						
						var currentDate = new Date(this.__fields.startDate);
						var endDate = new Date(this.__fields.endDate);
						var fields = this.__fields.interval.__fields;
						
						if (this.__fields.interval.isValid() && currentDate<=endDate) {
							while (currentDate <= endDate) {
								var currentTypeDate = Siviglia.types.TypeFactory.getType("", {TYPE: "DateTime"}, null, currentDate);
								list.push(currentTypeDate); // lo meteremos en un tipo Array de valores DateTime
								for (var field in fields) {
									n = this.__fields.interval.__fields[field].getValue();
									var exp = n + ".." + field + ".after(currentDate)";
									currentDate = eval(exp);
								}
							}
						}
						//var value = Siviglia.types.TypeFactory.getType("range", def, null, null);
						//value._setValue(list);
						//return value;
						return list;
					},
				}
			}
		}
	});


/*
librería an.hour.ago MODIFICADA	
 */

// MODIFICACIÓN: calcular diferencias de months y years (no se puede hacer sumando o restando milisegundos)
// se añaden las propiedades month/months y year/years y se procesan con setMonth, getMonth, setFullYear y getFullYear 
// ejemplo: d.setFullYear(d.getFullYear()+1). Ahora el constructor no recibe un valor en milisegundos, sino un objeto
// con propiedades type y value. El tipo es milisegundos para todas las unidades que tienen una duración fija.

// Generated by CoffeeScript 1.7.1
(function() {
	var $DC, $ND, DateComparator, NaturalDate, days, def, defineProperty, getter, hours, minutes, ms, now, numberProto, seconds, unit, units, weeks,
		__hasProp = {}.hasOwnProperty;

	defineProperty = Object.defineProperty;

	if (defineProperty == null) {
		defineProperty = function(object, name, descriptor) {
			return object.__defineGetter__(name, descriptor.get);
		};
	}

	def = function(object, name, get) {
		return defineProperty(object, name, {
			get: get
		});
	};

	now = Date.now || function() {
		return (new Date).getTime();
	};

	NaturalDate = (function() {
		function NaturalDate(delta) {
			this.value = delta.value;
			this.type = delta.type;
		}

		return NaturalDate;

	})();

	$ND = NaturalDate.prototype;

	$ND.and = function(naturalDate) {
		return new NaturalDate(this.value + naturalDate.valueOf());
	};

	$ND.before = function(date) {
		switch (this.type) {
			case "millisecond":
				return new Date(date.valueOf() - this.value);
			case "month":
				return new Date(date.setMonth(date.getMonth() - this.value));
			case "year":
				return new Date(date.setFullYear(date.getFullYear() - this.value));
			default:
				console.log("Tipo de periodo no soportado");
		}
	};

	$ND.from = $ND.after = function(date) {
		switch (this.type) {
			case "millisecond":
				return new Date(date.valueOf() + this.value);
			case "month":
				return new Date(date.setMonth(date.getMonth() + this.value));
			case "year":
				return new Date(date.setFullYear(date.getFullYear() + this.value));
			default:
				console.log("Tipo de periodo no soportado");
		}
	};

	$ND.valueOf = function() {
		return {
			type: this.type,
			value: this.value
		};
	};

	def($ND, 'ago', function() {
		return this.before(new Date(now()));
	});

	def($ND, 'from_now', function() {
		return this.after(new Date(now()));
	});

	DateComparator = (function() {
		function DateComparator(operator, self, offset) {
			this.operator = operator;
			this.self = self;
			this.offset = offset;
		}

		return DateComparator;

	})();

	$DC = DateComparator.prototype;

	$DC.before = function(date) {
		var other;
		other = date.valueOf() - this.offset;
		switch (this.operator) {
			case '<':
				return this.self > other;
			case '>':
				return this.self < other;
		}
	};

	$DC.from = $DC.after = function(date) {
		var other;
		other = date.valueOf() + this.offset;
		switch (this.operator) {
			case '<':
				return this.self < other;
			case '>':
				return this.self > other;
		}
	};

	$DC.either_side_of = function(date) {
		switch (this.operator) {
			case '<':
				return this.before(date) && this.after(date);
			case '>':
				return this.before(date) || this.after(date);
		}
	};

	def($DC, 'ago', function() {
		return this.before(now());
	});

	def($DC, 'from_now', function() {
		return this.from(now());
	});

	Date.prototype.less_than = function(offset) {
		return new DateComparator('<', this.valueOf(), offset);
	};

	Date.prototype.more_than = function(offset) {
		return new DateComparator('>', this.valueOf(), offset);
	};

	numberProto = Number.prototype;

	units = {
		millisecond: { type: "millisecond", value: 1 },
		second: seconds = { type: "millisecond", value: 1000 },
		minute: minutes = { type: "millisecond", value: 60 * 1000 },
		hour: hours = { type: "millisecond", value: 60 * 60 * 1000 },
		day: days = { type: "millisecond", value: 24 *  60 * 60 *  1000 },
		week: weeks = { type: "millisecond", value: 7 * 24 * 0  * 60 * 1000 },
		fortnight: { type: "millisecond", value: 2 * 7 * 24 * 60 * 60 * 1000 },
		month: months = { type: "month", value: 1 }, // existe la propiedad, pero no tiene un valor fijo
		year: years = { type: "year", value: 1 } // existe la propiedad, pero no tiene un valor fijo
	};

	for (unit in units) {
		if (!__hasProp.call(units, unit)) continue;
		time = units[unit];
		getter = (function(time) {
			return function() {
				delta = JSON.parse(JSON.stringify(time));
				delta.value *= this;
				return new NaturalDate(delta);
			};
		})(time);
		def(numberProto, unit, getter);
		def(numberProto, unit + 's', getter);
	}

}).call(this);