Siviglia.Utils.buildClass(
	{
		context: 'Siviglia.types',
		classes: {
			DateTimeRelative: {
				inherits: 'DateTime',
				constants: {
					PERIODS: {
						"default": ["years", "months", "days", "hours", "minutes", "seconds"],
						"en-US": ["years", "months", "days", "hours", "minutes", "seconds"],
						"es-ES": ["años", "meses", "días", "horas", "minutos", "segundos"],
					},
					SIGN: ["+", "-"],
				},
				methods: {
					getValue: function() {
						var delta = this.delta;
						if (delta === undefined)
							return this.DateTime$getValue();

						return this.DateTime$getValue();
					},
					setDelta: function(sign, value, period) {
						var exp = value + ".." + Siviglia.types.DateTimeRelative.PERIODS["default"][period];
						if (sign === 1) {
							exp += ".after(date)";
						} else {
							exp += ".before(date)";
						}
						return this.delta = exp;
					},
					getDate: function(sign, value, period) {
						var date = new Date(this.getValue());
						delta = this.setDelta(sign, value, period);
						date = eval(delta);
						return new Siviglia.types.DateTime("", [], null, date).getValue();
					},
				}
			},
			DateTimeInterval: {
				inherits: 'BaseType',
				methods: {
					construct: function(name, def, parentType, val, validationMode) {
						this.def = {
							'FIELDS': {
								'years': {
									'TYPE': 'Integer',
									'LABEL': 'Años',
									'DEFAULT': 0,
									'MIN': 0
								},
								'months': {
									'TYPE': 'Integer',
									'LABEL': 'Meses',
									'DEFAULT': 0,
									'MIN': 0
								},
								'days': {
									'TYPE': 'Integer',
									'LABEL': 'Días',
									'DEFAULT': 0,
									'MIN': 0
								},
								'hours': {
									'TYPE': 'Integer',
									'LABEL': 'Horas',
									'DEFAULT': 0,
									'MIN': 0
								},
								'minutes': {
									'TYPE': 'Integer',
									'LABEL': 'Minutos',
									'DEFAULT': 0,
									'MIN': 0
								},
								'seconds': {
									'TYPE': 'Integer',
									'LABEL': 'Segundos',
									'DEFAULT': 0,
									'MIN': 0
								}
							}
						};
						this.BaseType(name, this.def, parentType, val, validationMode);
					},
				}
			},
			DateTimeRange: {
				inherits: 'BaseType',
				methods: {
					construct: function(name, def, parentType, val, validationMode) {
						def = {
							FIELDS: {
								startDate: {
									TYPE: "DateTimeRelative",
									LABEL: "Fecha de inicio"
								},
								endDate: {
									TYPE: "DateTimeRelative",
									LABEL: "Fecha de fin"
								},
								interval: {
									TYPE: "DateTimeInterval",
									LABEL: "Intervalo"
								}
							},
						};
						this.BaseType(name, def, parentType, val, validationMode);
					},
					getValue: function() {
						var currentDate = this.startDate;
						var fields = this.interval.getDefinition();
						var list = [];
						while (currentDate<=this.endDate) {
							list.push(currentDate); // lo meteremos en un tipo Array de valores DateTime
							for(var field in fields) {
								//console.log(field);
								n = this.field.getValue();
								currentDate = n[field].after(currentDate);
							}
						}
						return list;
					},
				}
			}
		}
	});


/*
librería an.hour.ago MODIFICADA	
 */

// MODIFICACIÓN: calcular diferencias de months y years (no se puede hacer sumando o restando milisegundos)
// se añaden las propiedades month/months y year/years y se procesan con setMonth, getMonth, setFullYear y getFullYear 
// ejemplo: d.setFullYear(d.getFullYear()+1). Ahora el constructor no recibe un valor en milisegundos, sino un objeto
// con propiedades type y value. El tipo es milisegundos para todas las unidades que tienen una duración fija.

// Generated by CoffeeScript 1.7.1
(function() {
	var $DC, $ND, DateComparator, NaturalDate, days, def, defineProperty, getter, hours, minutes, ms, now, numberProto, seconds, unit, units, weeks,
		__hasProp = {}.hasOwnProperty;

	defineProperty = Object.defineProperty;

	if (defineProperty == null) {
		defineProperty = function(object, name, descriptor) {
			return object.__defineGetter__(name, descriptor.get);
		};
	}

	def = function(object, name, get) {
		return defineProperty(object, name, {
			get: get
		});
	};

	now = Date.now || function() {
		return (new Date).getTime();
	};

	NaturalDate = (function() {
		function NaturalDate(delta) {
			this.value = delta.value;
			this.type = delta.type;
		}

		return NaturalDate;

	})();

	$ND = NaturalDate.prototype;

	$ND.and = function(naturalDate) {
		return new NaturalDate(this.value + naturalDate.valueOf());
	};

	$ND.before = function(date) {
		switch (this.type) {
			case "millisecond":
				return new Date(date.valueOf() - this.value);
			case "month":
				return new Date(date.setMonth(date.getMonth() - this.value));
			case "year":
				return new Date(date.setFullYear(date.getFullYear() - this.value));
			default:
				console.log("Tipo de periodo no soportado");
		}
	};

	$ND.from = $ND.after = function(date) {
		switch (this.type) {
			case "millisecond":
				return new Date(date.valueOf() + this.value);
			case "month":
				return new Date(date.setMonth(date.getMonth() + this.value));
			case "year":
				return new Date(date.setFullYear(date.getFullYear() + this.value));
			default:
				console.log("Tipo de periodo no soportado");
		}
	};

	$ND.valueOf = function() {	
		return {
			type: this.type,
			value: this.value
		};	
	};

	def($ND, 'ago', function() {
		return this.before(new Date(now()));
	});

	def($ND, 'from_now', function() {
		return this.after(new Date(now()));
	});

	DateComparator = (function() {
		function DateComparator(operator, self, offset) {
			this.operator = operator;
			this.self = self;
			this.offset = offset;
		}

		return DateComparator;

	})();

	$DC = DateComparator.prototype;

	$DC.before = function(date) {
		var other;
		other = date.valueOf() - this.offset;
		switch (this.operator) {
			case '<':
				return this.self > other;
			case '>':
				return this.self < other;
		}
	};

	$DC.from = $DC.after = function(date) {
		var other;
		other = date.valueOf() + this.offset;
		switch (this.operator) {
			case '<':
				return this.self < other;
			case '>':
				return this.self > other;
		}
	};

	$DC.either_side_of = function(date) {
		switch (this.operator) {
			case '<':
				return this.before(date) && this.after(date);
			case '>':
				return this.before(date) || this.after(date);
		}
	};

	def($DC, 'ago', function() {
		return this.before(now());
	});

	def($DC, 'from_now', function() {
		return this.from(now());
	});

	Date.prototype.less_than = function(offset) {
		return new DateComparator('<', this.valueOf(), offset);
	};

	Date.prototype.more_than = function(offset) {
		return new DateComparator('>', this.valueOf(), offset);
	};

	numberProto = Number.prototype;

	units = {
		millisecond: { type: "millisecond", value: 1 },
		second: seconds = { type: "millisecond", value: 1000 },
		minute: minutes = { type: "millisecond", value: 60*1000 },
		hour: hours = { type: "millisecond", value: 60*60*1000 },
		day: days = { type: "millisecond", value: 24*60*60*1000 },
		week: weeks = { type: "millisecond", value: 7*24*60*60*1000 },
		fortnight: { type: "millisecond", value: 2*7*24*60*60*1000 },
		month: months = { type: "month", value: 1 }, // existe la propiedad, pero no tiene un valor fijo
		year: years = { type: "year", value: 1 } // existe la propiedad, pero no tiene un valor fijo
	};

	for (unit in units) {
		if (!__hasProp.call(units, unit)) continue;
		time = units[unit];
		getter = (function(time) {
			return function() {
				delta = JSON.parse(JSON.stringify(time));
				delta.value *= this;
				return new NaturalDate(delta);
			};
		})(time);
		def(numberProto, unit, getter);
		def(numberProto, unit + 's', getter);
	}

}).call(this);