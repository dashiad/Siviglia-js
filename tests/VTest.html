<html>
<head>
    <meta charset="UTF-8">
    <title>VTests</title>
    <script src="../../../node_modules/jquery/dist/jquery.js"></script>

    <script src="../../../packages/Siviglia/Siviglia.js"></script>
    <script src="../../../packages/Siviglia/SivigliaStore.js"></script>
    <script src="../../../packages/Siviglia/SivigliaTypes.js"></script>
    <script src="../../../packages/Siviglia/Model.js"></script>

    <link rel="stylesheet" href="dependencies/css/testStyles.css">

    <script src="../../../packages/Siviglia/ui/tests/dependencies/highlight/highlight.pack.js"></script>
    <link rel="stylesheet"
          href="../../../packages/Siviglia/ui/tests/dependencies/highlight/styles/monokai.css">

    <script src="../../../packages/Siviglia/ui/tests/dependencies/jsonView/jquery.json-view.min.js"></script>
    <link rel="stylesheet"
          href="../../../packages/Siviglia/ui/tests/dependencies/jsonView/jquery.json-view.min.css">
</head>
<body>
<div id="result"></div>

<script>
  var Siviglia = Siviglia || {};
  Siviglia.config = {
    baseUrl: 'http://editor.adtopy.com/',
    // staticsUrl: 'http://statics.adtopy.com/',
    staticsUrl: '../../../',
    metadataUrl:'http://metadata.adtopy.com/',
    jsFramework: 'jquery',
    locale: 'es-ES',
    mapper: 'Siviglia',
    datasourcePrefix: 'datasource/'
    //jsFramework:'dojo'
  };
  Siviglia.Model.initialize(Siviglia.config);
  Siviglia.debug=true;

  // Test extraction code: this code is added to extract the content from the tests to individual files
/*  function saveFileInUserStorage(filename, data, type) {
    const file = new Blob([data], { type: type })
    const a = document.createElement('a')
    const url = URL.createObjectURL(file)
    a.href = url
    a.download = filename
    document.body.appendChild(a)
    a.click()
    setTimeout(function () {
      document.body.removeChild(a)
      window.URL.revokeObjectURL(url)
    }, 0)
  }
  function getStringBetween(str, start, end) {
    const result = str.match(new RegExp(start + "(.*)" + end, 's'));

    return result[1];
  }
  function camelize(str) {
    return str.replace(/(?:^\w|[A-Z]|\b\w)/g, function(word, index) {
      return index === 0 ? word.toLowerCase() : word.toUpperCase();
    }).replace(/\s+/g, '');
  }
  var indexContent = `var testsList = [`*/
  // End extraction code initialization

    hljs.initHighlightingOnLoad();

    var urlParams = new URLSearchParams(window.location.search);
    var DEVELOP_MODE;
    if (!urlParams.has("test")) {
      //DEVELOP_MODE=47;    // Specific test number
      //DEVELOP_MODE=0;     // All tests
      //DEVELOP_MODE=(-1);  // Latest test
      DEVELOP_MODE = (-1);
    } else {
      DEVELOP_MODE = parseInt(urlParams.get("test"));
    }

    var def1={
        "TYPE":"Container",
        "FIELDS": {
            "one": {"TYPE": "String", "MINLENGTH": 2, "MAXLENGTH": 10},
            "two": {"TYPE": "String", "DEFAULT": "Hola"}
        }
    };

    var def2={
        "TYPE":"Container",
        "FIELDS":{
        "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":10},
        "two":{"TYPE":"String","REQUIRED":true},
        "three":{"TYPE":"Integer"},
        "four":{"TYPE":"Integer","KEEP_KEY_ON_EMPTY":true}
    }
    };

    var def3={
        "TYPE":"Container",
        "FIELDS":{
        "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":10},
        "two":{"TYPE":"String"}
    }
    };
    var def4={
        "TYPE":"Container",
        "FIELDS":{
        "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":10,"KEEP_KEY_ON_EMPTY":true},
        "two":{"TYPE":"String"}
    }
    };
    var def5={
        "TYPE":"Container",
        "FIELDS":{
        "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":10,"KEEP_KEY_ON_EMPTY":true},
        "two":{"TYPE":"String"}
    },
        "DEFAULT":{
        "one":"1111",
        "two":"2222"
    }
    };

    var def6={
        "TYPE":"Container",
        "FIELDS":{
            "one":{
                "TYPE":"Array",
                "ELEMENTS":{
                    "TYPE":"Container",
                    "FIELDS":{
                        "f1":{
                            "TYPE":"Dictionary",
                            "VALUETYPE":{
                                "TYPE":"Container",
                                "FIELDS": {
                                    "q1": {"TYPE": "String"},
                                    "q2": {"TYPE": "Integer"}
                                    }
                                }
                            },
                        "f2":{
                            "TYPE":"TypeSwitcher",
                            "TYPE_FIELD":"Type",
                            "CONTENT_FIELD":"Value",
                            "ALLOWED_TYPES":{
                                "String":{"TYPE":"String"},
                                "Integer":{"TYPE":"Integer"}
                            }
                        }
                    }
                }
            },
            "two":{"TYPE":"String"}
        }
    };

    var def = {
        "FIELDS": {
            "f1": {
                "TYPE": "Array",
                "VALUETYPE": {

                    "TYPE": "String"
                }
            },
            "f2": {
                "TYPE": "TypeSwitcher",
                "TYPE_FIELD": "TYPE",
                "ALLOWED_TYPES": {
                    "TIPO1": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "TYPE":{"TYPE": "String"},
                            "f3": {"TYPE": "String", "MINLENGTH": 2},
                            "f4": {"TYPE": "Integer"}
                        }
                    },
                    "TIPO2": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "TYPE":{"TYPE": "String"},
                            "f1": {"TYPE": "String", "MINLENGTH": 2},
                            "f2": {"TYPE": "Integer"}
                        }
                    }
                }
            },
            "f3": {
                "TYPE": "TypeSwitcher",
                "TYPE_FIELD": "TYPE",
                "IMPLICIT_TYPE": "TIPO3",
                "ALLOWED_TYPES": {
                    "TIPO3": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "TYPE":{"TYPE": "String"},
                            "f3": {"TYPE": "String", "MINLENGTH": 2},
                            "f4": {"TYPE": "Integer"}
                        }
                    },
                    "TIPO4": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "TYPE":{"TYPE": "String"},
                            "f1": {"TYPE": "String", "MINLENGTH": 2},
                            "f2": {"TYPE": "Integer"}
                        }
                    }
                }
            },
            "f4": {
                "TYPE": "TypeSwitcher",
                "TYPE_FIELD": "TYPE",
                "CONTENT_FIELD": "value",
                "IMPLICIT_TYPE": "TIPO6",
                "ALLOWED_TYPES": {
                    "TIPO6": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "TYPE":{"TYPE": "String"},
                            "f3": {"TYPE": "String", "MINLENGTH": 2},
                            "f4": {"TYPE": "Integer"}
                        }
                    },
                    "TIPO7": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "TYPE":{"TYPE": "String"},
                            "f1": {"TYPE": "String", "MINLENGTH": 2},
                            "f2": {"TYPE": "Integer"}
                        }
                    }
                }
            },
            s1: {
                "TYPE": "String",
                "MINLENGTH": 3,
                "MAXLENGTH": 4
            },
            s2: {
                "TYPE": "String",
                "REGEXP": "/aa/"
            }
        }
    };
    var testNumber = 0;
    var runningTests=false;
    var cbStack=[];
    function countListeners() {
        return Object.keys(Siviglia.Dom.existingListeners).length

    }
    function countManagers()
    {
        return Object.keys(Siviglia.Dom.existingManagers).length;
    }

    function createHTMLElement(tagName, className, parent, content) {
      var htmlElement = document.createElement(tagName)
      if (className)
        htmlElement.className = className
      if (content)
        htmlElement.innerHTML = content
      if (parent)
        parent.appendChild(htmlElement)

      return htmlElement
    }

    function createHTMLTestStructure(name, doc, def, callback, testNumber, expected, result, exception) {
      var className = "result resultError"
      var message = "ERROR"
      if (!exception) {
        if (JSON.stringify(expected) == JSON.stringify(result)) {
          className = "result resultOk"
          message = "OK!"
        }
      } else {
        message = 'A ocurrido una excepción en la ejecución del test: ' + exception
      }

      const testContainer = createHTMLElement('div', 'testDiv ' + className, document.body)
      const titleDiv = createHTMLElement('div', 'testTitle', testContainer, 'Test ' + testNumber + " (" + name + ") : " + message + " <i style='font-size:10px'>[listeners:" + countListeners() + " Managers:" + countManagers() + "]</i>")
      const descriptionDiv = createHTMLElement('div', 'testDoc', testContainer, doc)
      const contentContainer = createHTMLElement('div', 'testCont', testContainer)
      // contentContainer.style.height = "50px";
      const definitionContainer = createHTMLElement('div', 'testDef', contentContainer)
      definitionContainer.style.overflowY = "scroll";
      $(definitionContainer).jsonView(def);
      const codeContainer = createHTMLElement('div', 'testCode', contentContainer, "<pre>" + hljs.highlightAuto(callback.toString()).value + "</pre>")
      const clearDiv = createHTMLElement('div', '', testContainer)
      clearDiv.style.clear = "both";
    }
    function checkTests(restart)
    {
        if(runningTests==true)
        {
            return;
        }
        if(restart!==false) {
            if (DEVELOP_MODE !== 0) {
                if (DEVELOP_MODE === -1)
                    cbStack = [cbStack.pop()];
                else
                    cbStack = [cbStack[DEVELOP_MODE-1]];
            }
        }
        while(cbStack.length>0)
        {
            var cItem=cbStack.shift();
            try {
              // Test extraction start
/*              const testGroup = camelize(cItem.name.split(': ')[0])
                const definitionContent = '//definitionInit\n' + JSON.stringify(cItem.def, null, 2) + '\n//definitionEnd\n\n'
                const codeContent = '//codeInit\n' + getStringBetween(cItem.cb.toString(2), ' {\n', '}') + '  \n//codeEnd\n'
                const fileContent = '(function () {\n//callbackInit\ndef =\n' + definitionContent + codeContent + '//callbackEnd\n})'
                const testName = camelize(cItem.name.split(': ')[1])
                saveFileInUserStorage(testName + '.js', fileContent, 'text/javascript')

                indexContent += `{
  name: '${cItem.name}',
  description: '${cItem.doc}',
  path: '${testGroup}/${testName}.js'
},`*/
              // test extraction end

              var rs = cItem.cb.apply(null,[cItem.def]);
                if(rs && rs.then)
                {
                    // Es una promesa.
                    runningTests=true;
                    rs.then(function(r){
                        createHTMLTestStructure(cItem.name,cItem.doc,cItem.def,cItem.cb,cItem.number,cItem.expectedResult,r,null);
                        runningTests=false;
                        checkTests(false);
                    })
                    return;
                }
                else
                    createHTMLTestStructure(cItem.name,cItem.doc,cItem.def,cItem.cb,cItem.number,cItem.expectedResult,rs,null);

            } catch (e) {
                console.dir(e);
                createHTMLTestStructure(cItem.name,cItem.doc,cItem.def,cItem.cb,cItem.number,cItem.expectedResult,rs,e);
            }

        }

        // test extraction start
        /*indexContent += ']'
      saveFileInUserStorage('testsList.js', indexContent, 'text/javascript')*/
      //test extraction end
    }
    function runTest(name, doc, def,cb, expectedResult) {
        testNumber++;
        if(typeof expectedResult=="undefined")
            expectedResult=true;
        cbStack.push({name:name,doc:doc,def:def,cb:cb,expectedResult:expectedResult,number:testNumber});

    }
    runTest("Container: Simple Container","Prueba sencilla para comprobar que las librerias se inicializan correctamente",
       def1,
        function (def) {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            cnt.setValue({"one":"tres","two":"lalas"});
            var result=("tres"===cnt.one) && "lalas"===cnt.two;
            cnt.destruct();
            return result;
        });
    runTest("Container: Prueba de campo requerido", "El campo two es requerido, lo cual provoca error.Hay que fijarse en que esta comprobacion se efectua al llamarse a save(), no antes, ya que no podemos saber a priori si esos campos se van a establecer después.Hay que tener en cuenta que la validacion de formularios, y cualquier intento de enviar un BTO al servidor, tiene primero que llamar a save() del objeto.",
        def2,
        function (def) {
            var cnt = Siviglia.types.TypeFactory.getType({"fieldName":"a","fieldPath":"/"},def,null,null);
            var thrown=false;
            var result=true;
            try {
                cnt.setValue({one:"tres"});
                cnt.save();
            }catch(e)
            {
                result=result && e.type==="BaseTypedException" && e.code===Siviglia.model.BaseTypedException.ERR_REQUIRED_FIELD;
                // Tiene que estar errored.
                thrown=true;
            }
            cnt.destruct();
            return result && thrown;
        });
    runTest("Container: Prueba de campo erroneo","Se asigna un campo que no valida (cadena demasiado corta)",
    def1,
    function (def) {
        var thrown=false;
        var result=true;
        var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
        try {
            cnt.setValue({"one":"a","two":"lalas"});
        }catch(e)
        {
            result=(result && e.type=="StringException" && e.code==Siviglia.types.StringException.ERR_TOO_SHORT);
            thrown=true;
        }
        cnt.destruct();
        return result && thrown;
    });
    runTest("Container: Prueba de campo vacio","Se asigna un valor nulo, y se testea la funcion HasOwnValue",
    def1,
        function (def) {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            cnt.setValue(null);
            var status=cnt.__hasOwnValue()==false;
            cnt.destruct();
            return status;
        }
    )
    runTest("Container: Valor inicial nulo","Se comprueba que un container al que no se le ha asignado un valor, tiene un valor nulo",
    def1,
        function (def) {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            var n=cnt.getValue();
            cnt.destruct();
            return n===null;
        }
    )
    runTest("Container: Valor nulo de campos","Se comprueba que campos no asignados tienen un valor nulo",
        def2,
        function (def) {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            cnt.setValue({"one":"tres","two":"lalas"});
            var tmp=cnt.getValue();
            var status=tmp.three===null && tmp.four===null;
            cnt.destruct();
            return status;
        });
    runTest("Container: Valor por defecto de campos","Se comprueba que se aplica el valor por defecto cuando el campo se establece a nulo",
    def1,
        function (def) {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            cnt.setValue({"one":null,two:null});
            var status= cnt.two==="Hola";
            cnt.destruct();
            return status;
        }
    )
    runTest("Container: Valor nulo cuando todos los campos son nulos","Se comprueba que, si los campos de un container son nulos, y no tienen KEEP_KEY_ON_EMPTY, el valor del container es nulo,al convertirlo a un valor plano.",
        def3,
        function (def) {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            cnt.setValue({"one":null,two:null});
            var status=null===cnt.getPlainValue();
            cnt.destruct();
            return status;
        }
    )
    runTest("Container: Valor no nulo cuando todos los campos son nulos, preservando keys","Se comprueba que, si los campos de un container son nulos, pero tienen PRESERVE_KEYS_ON_NULL, el valor del container no es nulo, al convertirlo en un valor plano.",
        def4,
        function (def) {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            cnt.setValue({"one":null,two:null});
            var plain=cnt.getPlainValue();
            cnt.destruct();
            return null===plain.one;
        }
    )
    runTest("Container: Container usando BLANK_IS_NULL","Container: Valor nulo cuando: 1) BLANK_IS_NULL es true en el container, y no hay campos, o 2)BLANK_IS_NULL es true en el container, y los campos que se asignan, tambien tienen BLANK_IS_NULL, y estan en blanco.",
        {
            "TYPE":"Container",
            "BLANK_IS_NULL":true,
            "FIELDS":{
                "F1":{
                    "TYPE":"String",
                    "BLANK_IS_NULL":true
                }
            }
        },
        function (def) {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            cnt.setValue({});
            var status=cnt.__hasOwnValue()===false && cnt.__isEmptyValue({})===true;
            cnt.setValue({F1:""});
            status=status && cnt.__hasOwnValue()===false && cnt.__isEmptyValue({F1:""})===true;
            status=status && cnt.getValue()===null;
            cnt.setValue({F1:"aaa"});
            status=status && cnt.__hasOwnValue()===true && cnt.__isEmptyValue({F1:"aaa"})===false;

            cnt.destruct();
            return status;
        }
    )
    runTest("Container: Obtencion de path","Prueba de obtencion de campo a traves de un path",
        def6,
        function (def) {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            var v={
                "one":[
                    {
                        "f1": {
                            "k1-1": {"q1": "1", "q2": 2},
                            "k1-2": {"q1": "3", "q2": 4},
                            "k1-3": {"q1": "5", "q2": 6}
                        },
                        "f2": {
                            "Type": "String", "Value": "hola"
                        }
                    },

                    {
                        "f1":{
                            "k2-1":{"q1":"7","q2":8},
                            "k2-2":{"q1":"9","q2":10},
                        },
                        "f2":{
                            "Type":"String","Value":"hola"
                        }
                    }
                ],
                "two":"Lala"
            };
            cnt.setValue(v);
            var result= "Lala" === cnt.getPath("#two");
            cnt.destruct();
            v.__destroy__();
            return result;
        }
    )

    runTest("Container: Obtencion de path 2","Obtencion de un path mas profundo.Se comprueba que existen las claves de un container que existe dentro de varios campos.",
        def6,
        function (def) {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            cnt.setValue(
                {
                    "one":[
                        {
                            "f1": {
                                "k1-1": {"q1": "1", "q2": 2},
                                "k1-2": {"q1": "3", "q2": 4},
                                "k1-3": {"q1": "5", "q2": 6}
                            },
                            "f2": {
                                "Type": "String", "Value": "hola"
                            }
                        },

                        {
                            "f1":{
                                "k2-1":{"q1":"7","q2":8},
                                "k2-2":{"q1":"9","q2":10},
                            },
                            "f2":{
                                "Type":"String","Value":"hola"
                            }
                        }
                    ],
                    "two":"Lala"
                }
            );
            var val= cnt.getPath("#one/0/f1");
            var status=typeof val["k1-1"]!=="undefined" && typeof val["k1-2"]!=="undefined" && typeof val["k1-3"]!=="undefined" ;
            cnt.destruct();

            status = status && countListeners()==0
            return status;
        }
    )
    runTest("Container: Obtencion de path 3","Obtencion de un path relativo: Primero se navega hasta un cierto elemento de la estructura, y luego se pide un path relativo",
        def6,
        function (def) {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            cnt.setValue(
                {
                    "one":[
                        {
                            "f1": {
                                "k1-1": {"q1": "1", "q2": 2},
                                "k1-2": {"q1": "3", "q2": 4},
                                "k1-3": {"q1": "5", "q2": 6}
                            },
                            "f2": {
                                "Type": "String", "Value": "hola"
                            }
                        },

                        {
                            "f1":{
                                "k2-1":{"q1":"7","q2":8},
                                "k2-2":{"q1":"9","q2":10},
                            },
                            "f2":{
                                "Type":"String","Value":"hola"
                            }
                        }
                    ],
                    "two":"Lala"
                }
            );
            var arr=cnt["*one"];
            var cnt2=arr[0];
            var dict=cnt2["*f1"];
            var cnt3=dict["*k1-1"];
            var field=cnt3["*q1"];
            var parent=field.__getParent();
            var v1=parent.getPath("#../k1-2/q1");
            var v2=parent.getPath("#../../f2/Value");
            console.log("ANTES:"+countListeners());
            cnt.destruct();
            var n=countListeners();
            return v1==="3" && v2==="hola" && countListeners()==0;
        }
    )

    runTest("Container: Chequeo de fuente","Establecimiento de un valor dependiente de una fuente. La fuente de un campo, es el valor de otro campo.Se prueba tanto un valor valido, como un valor no valido.",
        {
            "TYPE":"Container",
        "FIELDS":{
        "VALUES":{
        "TYPE":"Array",
        "ELEMENTS":{
        "TYPE":"Container",
        "FIELDS":{
        "VALUE":{"TYPE":"Integer"},
    "LABEL":{"TYPE":"String"}
    }
    }
    },
    "DEFAULT":{"TYPE":"String",
        "SOURCE":{
        "TYPE":"Path",
        "PATH":"#../VALUES",
        "LABEL":"LABEL",
        "VALUE":"LABEL"
    }
    }
    }
    },
        function (def) {

            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            var thrown=false;
            try {
                cnt.setValue(
                    {
                        "VALUES": [
                            {"VALUE": 1, "LABEL": "Pepito"},
                            {"VALUE": 2, "LABEL": "Juanito"}
                        ],
                        "DEFAULT": "Pepito"
                    }
                );
            }catch(e)
            {
                thrown=true;
            }
            var res= thrown===false;
            // Se intenta ahora ponerle un valor que NO existe en la fuente:
            var thrown=false;
            try{
                cnt.DEFAULT="Invalid"
            }catch(e)
            {
                thrown=true;

            }
            cnt.destruct();
            var t=countListeners();
            return res && thrown && t==0;
        }
    )
    runTest("String: Varios test de String", "Se prueba la validacion de Strings, y como añadir un listener de CHANGE a un campo.Este listener se dispara tambien cuando hay un error. Un contador cuenta el numero de CHANGES, y el numero de errores.",def,function (def) {

        var t1 = new Siviglia.model.BaseTypedObject(def);
        var flag = 0;
        var nExcp = 0;
        var nErrors=0;
        t1.setValue({});
        t1["*s1"].addListener("ERROR", null, function () {
            nErrors++;

        })
        t1["*s1"].addListener("CHANGE", null, function () {
            flag++;

        })
        try {
            t1.s1 = "aa";
        } catch (e) {
            nExcp++;
        }
        try {
            t1.s1 = "zzzzzz";
        } catch (e) {
            nExcp++;
        }
        t1.s1 = "aaa";

        var n = countListeners();
        t1.destruct();
        var n1 = countListeners();
        return nExcp == 2 &&  flag===1 && nErrors==2 && n == 2 && n1 == 0;
    }, true);
    runTest("String: Comprobacion de BLANK_IS_NULL en String","Se comprueba el funcionamiento de BLANK_IS_NULL en Strings",
        {
            "FIELDS":{
                "s1":{
                    "TYPE":"String",
                    "BLANK_IS_NULL":true
                }
            }
        },
    function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.s1="";
        var status=t1["*s1"].__hasOwnValue()===false && t1["*s1"].__isEmptyValue("")===true;
        t1.s1="hola";
        status=t1["*s1"].__hasOwnValue()===true && t1["*s1"].__isEmptyValue("hola")===false;
        t1.destruct();
        return status
    })
    runTest("BaseTypedObject: Comprobacion de nulos (1)","Se prueba que un valor no asignado devuelve nulo", def,function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        var status=t1.f2===null;
        t1.destruct();
        return status;
    }, true);
    runTest("BaseTypedObject: Comprobacion de nulos (2)","Se prueba que un valor no asignado devuelve nulo", def,function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        var status=t1.f3===null;
        t1.destruct();
        return status;
    }, true);
    runTest("BaseTypedObject: Comprobacion de nulos (3)","Se prueba que un valor no asignado devuelve nulo", def,function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        var status=t1.f4===null;
        t1.destruct();
        return status;
    }, true);
    runTest("TypeSwitcher: Comprobacion TS 1", "Primera comprobacion de funcionamiento de un typeswitcher.Se ve que una vez establecido el tipo, los campos internos existen. Hay que tener en cuenta que hay que establecer al menos 1 campo, ya que, si no, el container tendria todos los campos a nulo, y, sin KEEP_KEY_ON_EMPTY, el container en si seria nulo.",
        def,
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.f2 = {TYPE: "TIPO1","f3":"aaa"};
        var s=t1.f2.f3;
        var status= typeof t1.f2.f3 !== "undefined" && typeof t1.f2["*f3"] !== "undefined" &&
               typeof t1.f2.f4 !== "undefined" && typeof t1.f2["*f4"] !== "undefined";
        t1.destruct();
        return status;
    }, true);
    runTest("TypeSwitcher: Comprobacion TS 2", "Comprobacion del funcionamiento de IMPLICIT_TYPE: Si a un typeswitcher se le asigna un valor que no tiene el campo definido como campo de tipo, se utiliza el tipo indicado por IMPLICIT_TYPE",
        def,
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.f3 = {f3:"qqq"};
        var status= typeof t1.f3.f3 !== "undefined" && typeof t1.f3["*f3"] !== "undefined" && typeof t1.f3.f4 !== "undefined" && typeof t1.f3["*f4"] !== "undefined";
            t1.destruct();
            return status;
    }, true);
    runTest("TypeSwitcher: Comprobacion TS 3", "Comprobacion de que en un typeswitcher, al cambiar de tipo (primero se crea un tipo implicito, y luego un TIPO4), los campos pertenecientes al primer tipo, ya no estan definidos.",
        def,
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.f3 = {f3:"aaa"};
        var result=typeof t1.f3.f3 !=="undefined";
        t1.f3 = {"TYPE": "TIPO4"}
        var thrown=false;
        try {
            var v1 = t1.f3.f3;
        }
        catch(e)
        {
            thrown=true;
        }
        t1.destruct();
        return thrown;
    }, true);
    runTest("TypeSwitcher: Comprobacion TS 4", "Comprobacion de acceso a un TypeSwitcher a traves de campos",def,
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.f4 = {value: {f3: "hola", f4: 25}};
        t1.f4.value.f3 = "pepito"
        var status= t1.f4.value.f3==="pepito";
        t1.destruct();
        return status;
    });
    runTest("TypeSwitcher: Comprobacion Listener TS 1", "Comprobacion del funcionamiento de listeners sobre typeswitchers: se establece un listener para escuchar cuando cambia el tipo del typeswitcher",def,
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.f4 = {value: {f3: "hola", f4: 25}};
        var flag = 0;
        t1["*f4"].addListener("CHANGE", null, function () {
            flag = 1;
        })
        var n = countListeners();
        t1.f4.TYPE = "TIPO7";
        t1.destruct();
        var n2 = countListeners();
        return flag == 1 && n2 == 0 && n == 1;
    }, true);
    runTest("TypeSwitcher: Comprobacion Listener TS 2", "Comprobacion del funcionamiento de listener de TypeSwitcher, al establecer el valor a nulo (hay que fijarse en que el listener se establece justo antes de establecer el valor a nulo.)",def,function () {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.f4 = {};
        t1.f4 = {value: {f3: "hola", f4: 25}};
        var flag = 0;
        t1["*f4"].addListener("CHANGE", null, function () {
            flag = 1;
        })
        var n = countListeners();
        t1.f4 = null;
        t1.destruct();
        var n2 = countListeners();
        return flag == 1 && n2 == 0 && n == 1;
    }, true);
    runTest("TypeSwitcher: Comprobacion Listener TS 3", "Se establecen listeners sobre campos internos del typeswitcher.Se comprueba tambien que no quedan listeners colgados",def,
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.f4 = {value: {f3: "hola", f4: 25}};
        var flag = 0;
        var fire1=0,fire2=0,fire3=0,f3FiredFirst=false;
        t1["*f4"].addListener("CHANGE", null, function () {
            flag++;
            fire1=1;
        }, "Listener t4");
        t1["*f4"]["*value"].addListener("CHANGE", null, function () {
            flag++;
            fire2=1;
        }, "Listener value")
        t1.f4.value["*f3"].addListener("CHANGE", null, function () {
            flag++;
            fire3=1;
            if(fire1==0)
                f3FiredFirst=true;
        }, "Listener f3")
        var n = countListeners();
        t1.f4.value.f3 = "adios";
        t1.f4.TYPE = "TIPO7";
        t1.destruct();
        var n2 = countListeners();
        return flag == 2 && n2 == 0 && n == 3 && f3FiredFirst==true && fire3==1 && fire1==1;
    }, true);

    runTest("BaseTypedObject: Comprobacion save() en BaseTypedObject",
        "Se comprueba el funcionamiento de Save en BaseTypedObject.Al llamar a save() se hacen las comprobaciones de los campos requeridos.Se intenta primero salvar un objeto incompleto, lo que tiene que hacer saltar una excepcion.Al establecer el valor que falta, la excepcion no debe saltar, por lo que se debe haber mantenido el valor de la variable e1",
        {
            "FIELDS": {
                "f1": {"TYPE": "String", "REQUIRED": true},
                "f2": {"TYPE": "String"}
            }
        },
        function (def) {
        var t2 = new Siviglia.model.BaseTypedObject(def);
        t2.f2 = "Lala";
        var e1 = 0;
        var errors=null;
        try {
            t2.save();

        } catch (e) {
            if(e.code && e.code==Siviglia.model.BaseTypedException.ERR_REQUIRED_FIELD)
                    e1 = 1;

        }
        t2.f1 = "qqq";
        try {

            var errors=t2.save();
            if(errors && errors.length>0)
                e1=2;
        } catch (e) {
        }
        t2.destruct();
        return e1===1;
    });
    runTest("BaseTypedObject: Comprobacion de getPath en BaseTypedObject y TypeSwitcher",
        "Se comprueba el funcionamiento de getFullPath, que debe calcular el path completo de un campo.Aqui, el typeswitcher en si, no debe añadir nada al path.Ese campo debe ser transparente.",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "TypeSwitcher",
                    "TYPE_FIELD": "TYPE",
                    "CONTENT_FIELD": "value",
                    "ALLOWED_TYPES": {
                        "TIPO3": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "sf3": {"TYPE": "String", "MINLENGTH": 2},
                                "sf4": {"TYPE": "Integer"}
                            }
                        },
                        "TIPO4": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "sf1": {"TYPE": "String", "MINLENGTH": 2},
                                "sf2": {"TYPE": "Integer"}
                            }
                        }
                    }
                },
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.f3 = {TYPE: "TIPO3", value: {sf3: "lala"}};
        var path = t1.f3.value["*sf3"].__getFieldPath();
        t1.destruct();
        return path == "/f3/value/sf3";
    }, true);

    runTest("BaseTypedObject: Comprobacion de KEEP_ON_EMPTY en BaseTypedObject",
        "Se comprueba el funcionamiento de KEEP_ON_EMPTY.Un campo con el flag KEEP_ON_EMPTY se devuelve como NULL si no se ha asignado un valor.",
        {
            "FIELDS": {
                "f1": {"TYPE": "String", "KEEP_KEY_ON_EMPTY": true},
                "f2": {"TYPE": "String", "KEEP_KEY_ON_EMPTY": false}
            }
        },
        function (def) {
        var t2 = new Siviglia.model.BaseTypedObject(def);
        var r = t2.getPlainValue();
        var status=typeof r["f2"] == "undefined" && r.f1 === null;
        t2.destruct();
        return status;
    }, true);
    runTest("BaseTypedObject: Comprobacion de DEFAULT en BaseTypedObject", "Se establece el valor por defecto de un BaseTypedObject completo",
        {
            "FIELDS": {
                "f2": {"TYPE": "String"},
                "TIPO2": {
                    "TYPE": "Container",
                    "FIELDS": {
                        "f1": {"TYPE": "String", "MINLENGTH": 2},
                        "f2": {"TYPE": "Integer"}
                    }
                }
            },
            "DEFAULT": {f2: "hola", TIPO2: {f1: "adios", f2: 50}}
        },
        function (def) {
        var t2 = new Siviglia.model.BaseTypedObject(def);
        var status= t2.f2 == "hola" && t2.TIPO2.f2 == 50;
        t2.destruct();
        return status;
    }, true);
    runTest("Container: Comprobacion de save() en Container",
        "Se intenta guardar un objeto Container con un valor interno que es requerido.Cuando ese valor se establece, se deja de lanzar la excepcion",
        {
            "FIELDS": {
                "f2": {"TYPE": "String"},
                "TIPO2": {
                    "TYPE": "Container",
                    "FIELDS": {
                        "f1": {"TYPE": "String", "MINLENGTH": 2, "REQUIRED": true},
                        "TIPO7": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "f1": {"TYPE": "String", "MINLENGTH": 2},
                                "f2": {"TYPE": "Integer"}
                            }
                        }
                    }
                }
            },

        },
        function (def) {

        var t2 = new Siviglia.model.BaseTypedObject(def);
        var e = 0;
        var result=false;
        t2.TIPO2 = {"TIPO7": {f1: "Prueba", f2: 55}};
        try {
            t2.save();
        } catch (q) {
            result=(q.type=="BaseTypedException" && q.code==Siviglia.model.BaseTypedException.ERR_REQUIRED_FIELD);
        }
        t2.TIPO2.f1 = "lala";
        t2.save();
        t2.destruct();
        return result;

    }, true);


    runTest("Container: Comprobacion de getPath en Container",
        "Comprobacion de calculo correcto de paths de campos",
        {
            "FIELDS": {
                "f2": {"TYPE": "String"},
                "TIPO2": {
                    "TYPE": "Container",
                    "FIELDS": {
                        "f1": {"TYPE": "String", "MINLENGTH": 2},
                        "TIPO7": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "f1": {"TYPE": "String", "MINLENGTH": 2},
                                "f2": {"TYPE": "Integer"}
                            }
                        }
                    }
                }
            },

        },
        function (def) {

        var t2 = new Siviglia.model.BaseTypedObject(def);
        t2.TIPO2 = {"f1": "hola", "TIPO7": {f1: "Prueba", f2: 55}};
        var path = t2.TIPO2.TIPO7["*f2"].__getFieldPath();
        var status = path == "/TIPO2/TIPO7/f2";
        t2.destruct();
        return status;

      }, true);

    runTest("Container: Comprobacion de SET_ON_EMPTY y KEEP_ON_EMPTY en Container",
        "Comprobacion de KEEP_KEY_ON_EMPTY y SET_ON_EMPTY",
        {
            "FIELDS": {
                "f1": {
                    "TYPE": "Container",

                    "SET_ON_EMPTY": true,
                    "FIELDS": {
                        "f1": {"TYPE": "String", "MINLENGTH": 2},
                        "f2": {"TYPE": "Integer"}
                    }
                },
                "TIPO2": {
                    "TYPE": "Container",
                    "SET_ON_EMPTY": false,
                    "FIELDS": {
                        "f1": {"TYPE": "String", "MINLENGTH": 2, "KEEP_KEY_ON_EMPTY": true},
                        "TIPO7": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "f1": {"TYPE": "String", "MINLENGTH": 2},
                                "f2": {"TYPE": "Integer"}
                            }
                        }
                    }
                }
            }

        },
        function (def) {

        var t2 = new Siviglia.model.BaseTypedObject(def);
        // NOTA: El path /TIPO2, tiene SET_ON_EMPTY a falso, pero a su vez tiene el campo f1 que tiene KEEP_ON_EMPTY a true.
        var r = t2.getPlainValue();
        // Lo que tiene que haber aqui es:
        // r.f1 : al tener SET_ON_EMPTY a true, pero sus campos son nulos, r.f1=={}
        // r.TIPO2 debe ser igual a {f1:null}
        var nKeys = 0;
        for (var k in r.f1)
            nKeys++;
        var status= nKeys == 0 && typeof r.TIPO2 !== "undefined" && r.TIPO2 != null && typeof r.TIPO2.TIPO7 == "undefined" && r.TIPO2.f1 == null;
        t2.destruct();
        return status;

    }, true)
    runTest("Dictionary: Comprobacion de getPath y DEFAULT en Dictionary",
        "Comprobaciones de valor por defecto y getPath en tipos Dictionary",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Dictionary",

                    "VALUETYPE": {

                        "TYPE": "Container",
                        "FIELDS": {
                            "sf3": {"TYPE": "String", "MINLENGTH": 2},
                            "sf4": {"TYPE": "Integer"}
                        }
                    },
                    "DEFAULT": {

                        "uno": {sf3: "Hola", sf4: 1},
                        "dos": {sf3: "Hola2", sf4: 2},
                        "tres": {sf3: "Hola3", sf4: 3},

                    }


                }
            }

        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);

        var path = t1.f3.uno["*sf3"].__getFieldPath();
        var status= path == "/f3/uno/sf3";
        t1.destruct();
        return status && countListeners()==0;
    }, true);
    runTest("Dictionary: Comprobacion de SET_ON_EMPTY en Dictionary",
        "Comprobacion del flag SET_ON_EMPTY en diccionarios",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Dictionary",
                    "ALLOW_EMPTY_VALUES":true,
                    "SET_ON_EMPTY": true,
                    "VALUETYPE": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "sf3": {"TYPE": "String", "MINLENGTH": 2},

                        }
                    },
                },
                "f4": {
                    "TYPE": "Dictionary",
                    "VALUETYPE": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "sf3": {"TYPE": "String", "MINLENGTH": 2},
                        }
                    },
                }
            }

        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);

        t1.f3 = {};
        t1.f4 = {};
        var r = t1.getPlainValue();

        var status =  typeof r.f3 == "object" && typeof r.f4 == "undefined";
        t1.destruct();
        return status && countListeners()==0;
    }, true);
    runTest("Dictionary: Comprobacion de ALLOW_NULL_VALUES en Dictionary",
        "Comprobacion del flag SET_ON_EMPTY en diccionarios",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Dictionary",
                    "ALLOW_NULL_VALUES":false,
                    "SET_ON_EMPTY": true,
                    "REQUIRED":true,
                    "VALUETYPE": {
                        "TYPE": "String"
                    },
                },
                "f4": {
                    "TYPE": "Dictionary",
                    "ALLOW_NULL_VALUES":true,
                    "SET_ON_EMPTY": false,
                    "REQUIRED":true,
                    "VALUETYPE": {
                        "TYPE": "Integer"
                    }
                }
            }

        },
        function (def) {
            var t1 = new Siviglia.model.BaseTypedObject(def);

            t1.f3 = {};
            var status=true;

            // No se ha establecido f4, que es requerido, asi que debe lanzarse una excepcion.
            var testField=function(field,value,expectException)
            {
                var excpThrown=false;
                var result=true;
                try{
                    t1[field]=value;
                    t1.save();
                }catch(e)
                {
                    excpThrown=true;
                    result=expectException && e.path==="/f4" && e.code===Siviglia.model.BaseTypedException.ERR_REQUIRED_FIELD;
                }
                return result && expectException===excpThrown;
            }

            status=status && testField("f4",null,true);
            // Si le damos un valor vacio, deberia seguir dando una excepcion, porque
            // es equivalente a ser nulo.
            status=status && testField("f4",{},true);
            // Se le asigna un valor correcto a t1.f4
            status=status && testField("f4",{aa:11},false);
            // Se asigna un valor con un null, y, como se permiten valores nulos, deberia seguir siendo correcto:
            status=status && testField("f4",{aa:null},false);
            // Obtenemos el valor de f4, para estar seguro de que es lo que queremos.
            var curVal=t1.getPlainValue();
            status=status && curVal.f4.aa===null;
            // Comienzn las pruebas con el campo f3
            // f3 no va a dar una excepcion, porque aunque se le pasa un valor con una key nula,
            // y ALLOW_NULL_VALUES es false, al tener SET_ON_EMPTY=true, no da error.
            status=status && testField("f3",{aa:null},false);
            // Comprobamos que, efectivamente, no existe ningun valor en f3
            curVal=t1.getPlainValue();
            var n=0;
            for(var k in curVal.f3)
                n++;
            status=status && n==0;

            t1.destruct();
            return status && countListeners()==0;
        }, true);

    runTest("Dictionary: Test simple de dictionary (1)",
        "Pruebas de funcionamiento simple de diccionarios, incluyendo listeners",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Dictionary",
                    "SET_ON_EMPTY": true,
                    "VALUETYPE": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "sf3": {"TYPE": "String", "MINLENGTH": 2},

                        }
                    },
                },
                "f4": {
                    "TYPE": "Dictionary",
                    "VALUETYPE": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "sf3": {"TYPE": "String", "MINLENGTH": 2},
                        }
                    },
                }
            }

        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        var nChanges=0;
        t1["*f3"].addListener("CHANGE",function(){
            nChanges++;
        })
        t1.f3 = {uno: {sf3: "a1"}, dos: {sf3: "a2"}};
        t1.f3.tres={sf3:"a3"};
        t1.f3.cinco = {sf3: "a4"}
        var nKeys = 0;
        for (var k in t1.f3)
            nKeys++;
        var status = nKeys == 4 && t1.f3.cinco.sf3 == "a4" && nChanges==3;
        t1.destruct();
        return status && countListeners()==0;
    }, true);
    runTest("Dictionary: Test simple de dictionary (2)",
        "Se comprueba que no se disparan listeners en los objetos que mantienen copias",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Dictionary",
                    "SET_ON_EMPTY": true,
                    "VALUETYPE": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "sf3": {"TYPE": "String", "MINLENGTH": 2},

                        }
                    }
                }
            }

        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);

        var nChanges = 0;
        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges++
        });

        t1.f3 = {uno: {sf3: "a1"}, dos: {sf3: "a2"}};

        var h={};
        h.q=t1["*f3"].getValue();
        Siviglia.Path.eventize(h,"q");
        var nRefChanges=0;
        h["*q"].addListener("CHANGE",function(){nRefChanges++;});
        // Mientras siga siendo el mismo objeto, se deben seguir recibiendo eventos:
        t1.f3.tres={sf3:"cc"};
        var status=(nRefChanges==1 && nChanges==2);

        // Ahora se cambia el valor completamente.Esto no deberia generar eventos en h.q
        t1.f3={"cuatro":{sf3:"dd"},"cinco":{sf3:"ee"}};
        status = status && (nRefChanges==1 && nChanges==3);

        delete t1.f3.cuatro;
        var q=t1.f3.cuatro;
        var ss=t1.f3["[[KEYS]]"];
        status = status && ss.length==1 && (ss[0].LABEL=="cinco") &&
            (typeof t1.f3.cuatro === "undefined") &&
            (typeof t1.f3["*cuatro"] === "undefined");



        t1.destruct();


        // Sin embargo, hay que tener en cuenta que el listener de h.q es ahora "anonimo".
        // h.q no tiene un destruct (era un objeto plano), pero mantiene una referencia a un EventListener,
        // por lo que aun debe haber 1 listener activo.
        status = status && countListeners()==1;
            h.__destroy__();
        // Se limpian manualmente los listeners.
        Siviglia.Dom.existingListeners=[];
        return status;
    }, true);
    runTest("Dictionary: Comprobacion de BLANK_IS_NULL en Dictionary","Se comprueba la funcionalidad de BLANK_IS_NULL en Dictionary",
        {
            "FIELDS":{
                "d1":{
                    "TYPE":"Dictionary",
                    "BLANK_IS_NULL":true,
                    "VALUETYPE":{
                        "TYPE":"String",
                        "BLANK_IS_NULL":true
                    }
                }
            }
        },
        function (def) {
            var t1 = new Siviglia.model.BaseTypedObject(def);
            t1.d1={};
            var status=t1["*d1"].__hasOwnValue()===false && t1["*d1"].__isEmptyValue({})===true;
            t1.d1={a:""};
            status=status && t1["*d1"].__hasOwnValue()===false && t1["*d1"].__isEmptyValue({a:""})===true;
            t1.d1={a:"hola"};
            status=status && t1["*d1"].__hasOwnValue()===true && t1["*d1"].__isEmptyValue({a:"hola"})===false;
            t1.destruct();
            return status;

        }
    )


    runTest("TypeSwitcher: Comprobacion de DEFAULT en  TypeSwitcher (1)",
        "Prueba de vlor por defecto en TypeSwitcher",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "TypeSwitcher",
                    "TYPE_FIELD": "TYPE",
                    "CONTENT_FIELD": "value",
                    "ALLOWED_TYPES": {
                        "TIPO3": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "sf3": {"TYPE": "String", "MINLENGTH": 2},
                                "sf4": {"TYPE": "Integer"}
                            }
                        },
                        "TIPO4": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "sf1": {"TYPE": "String", "MINLENGTH": 2},
                                "sf2": {"TYPE": "Integer"}
                            }
                        }
                    },
                    "DEFAULT": {
                        "TYPE": "TIPO3",
                        "value": {
                            sf3: "aaa",
                            "sf4": 10
                        }
                    }
                },
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);

        var v = t1.f3.value.sf4;
        var status= v == 10;
        t1.destruct();
        return status;
    }, true);

    runTest("TypeSwitcher: Comprobaciones de TypeSwitcher (1)",
        "Varias comprobaciones del funcionamiento normal de TypeSwitchers",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "TypeSwitcher",
                    "TYPE_FIELD": "TYPE",
                    "CONTENT_FIELD": "value",
                    "ALLOWED_TYPES": {
                        "TIPO3": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "sf3": {"TYPE": "String", "MINLENGTH": 2},
                                "sf4": {"TYPE": "Integer"}
                            }
                        },
                        "TIPO4": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "sf1": {"TYPE": "String", "MINLENGTH": 2},
                                "sf2": {"TYPE": "Integer"}
                            }
                        }
                    },
                    "DEFAULT": {
                        "TYPE": "TIPO3",
                        "value": {
                            sf3: "aaa",
                            "sf4": 10
                        }
                    }
                },
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        var nChanges = 0;
        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges++
        });
        // Comprobamos que, en este punto, ya que t1.f3.TYPE=="TIPO3" (por el valor por defecto),
        // existen sf3 y sf4:
        var initStatus = (t1.f3.value.sf3 === "aaa" && nChanges == 0);
        var thrown=false;
        try{
            var v1=t1.f3.value.sf2;
        }catch(e)
        {
            thrown=true;
        }
        initStatus=initStatus && thrown;
        // Se cambia ahora el tipo del typeswitcher.Tienen que haber desaparecido los tipos anteriores,
        // y aparecer los nuevos campos, aunque esten a nulo.
        t1.f3.TYPE = "TIPO4";
        t1.f3.value={};
        thrown=false;
        var secondStatus = (t1.f3.value.sf1 == null  && nChanges == 1);
        try{
            v1=t1.f3.value.sf3;
        }catch(e)
        {
            thrown=true;
        }
        secondStatus=secondStatus && thrown;
        // Se deshace el cambio.
        t1.f3.TYPE = "TIPO3";
        t1.f3.value={};

        var thirdStatus = (t1.f3.value.sf3 == null && nChanges == 2);
        thrown=false;
        try{
            v1=t1.f3.value.sf1;
        }catch(e)
        {
            thrown=true;
        }
        thirdStatus=thrown && thirdStatus;
        t1.destruct();
        return initStatus && secondStatus && thirdStatus && countListeners() === 0;
    }, true);

    runTest("TypeSwitcher: Comprobaciones de TypeSwitcher (2)",
        "Mismas comprobaciones que el test anterior, pero sin 'CONTENT_FIELD' en el TypeSwitcher",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "TypeSwitcher",
                    "TYPE_FIELD": "TYPE",
                    "ALLOWED_TYPES": {
                        "TIPO3": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "sf3": {"TYPE": "String", "MINLENGTH": 2},
                                "sf4": {"TYPE": "Integer"}
                            }
                        },
                        "TIPO4": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "sf1": {"TYPE": "String", "MINLENGTH": 2},
                                "sf2": {"TYPE": "Integer"}
                            }
                        }
                    },
                    "DEFAULT": {
                        "TYPE": "TIPO3",
                        sf3: "aaa",
                        "sf4": 10
                    }
                },
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
           def
        );

        // Comprobamos que, en este punto, ya que t1.f3.TYPE=="TIPO3" (por el valor por defecto),
        // existen sf3 y sf4:
        var initStatus = (t1.f3.sf3 === "aaa");
        var thrown=false;
        try{
            var val= t1.f3.sf2;
        }catch(e)
        {
            thrown=true;
        }
        initStatus=initStatus && thrown;
        // Se cambia ahora el tipo del typeswitcher.Tienen que haber desaparecido los tipos anteriores,
        // y aparecer los nuevos campos, aunque esten a nulo.
        t1.f3.TYPE = "TIPO4";
        var secondStatus = (t1.f3.sf1 == null);
        thrown=false;
        try {
            val=t1.f3.sf3;
        }catch(e)
        {
            thrown=true;
        }
        secondStatus=secondStatus && thrown;
        // Se deshace el cambio.
        t1.f3.TYPE = "TIPO3";
        thrown=false;
        var thirdStatus = (t1.f3.sf3 == null);
        try{
            val=t1.f3.sf1;
        }catch(e)
        {
            thrown=true;
        }
        thirdStatus=thirdStatus && thrown;
        t1.destruct();
        return initStatus && secondStatus && thirdStatus && countListeners() == 0;
    }, true);
    runTest("TypeSwitcher: Comprobaciones de TypeSwitcher (3)",
        "Comprobación del funcionamiento del valor * en ALLOWED_TYPES",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "TypeSwitcher",
                    "TYPE_FIELD": "TYPE",
                    "IMPLICIT_TYPE": "ModelReference",
                    "ALLOWED_TYPES": {
                        "String": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "TYPE": {"TYPE": "String", "FIXED": "String"},
                                "MINLENGTH": {"TYPE": "Integer"},
                                "MAXLENGTH": {"TYPE": "Integer"},
                                "REGEXP": {"TYPE": "String"}
                            }
                        },
                        "Integer": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "TYPE": {"TYPE": "String", "FIXED": "Integer"},
                                "MIN": {"TYPE": "Integer"},
                                "MAX": {"TYPE": "Integer"}
                            }
                        },
                        "*": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "TYPE": {"TYPE": "String"},
                                "F1": {"TYPE": "Integer"},
                                "F2": {"TYPE": "Integer"}
                            }
                        }
                    }
                }
            }
        },
        function (def) {
            var t1 = new Siviglia.model.BaseTypedObject(def);
            var nChanges = 0;
            t1["*f3"].addListener("CHANGE", null, function () {
                nChanges++
            });
            t1.f3={"TYPE":"Integer","MAX":10};
            var status=nChanges===1 && 10===t1.f3.MAX;

            t1.f3={"TYPE":"NO_DEFINIDO","F1":15};
            status=status && 15===t1.f3.F1 && "NO_DEFINIDO"===t1.f3.TYPE;

        // Asignamos el tipo "inline", asignando al campo, no llamando a setValue
            t1.f3.TYPE="OOOTRO";
            t1.f3.F1=22;
            status=status && "OOOTRO"===t1.f3.TYPE;
        // Cambiamos el tipo a traves de los campos:
            t1.f3.TYPE="String";
            t1.f3.MAXLENGTH=10;
            status=status && "String"===t1.f3.TYPE;
        // No se puede acceder a los campos del tipo "*"
            exceptionThrown=false;

            var p=t1.f3;
            var thrown=false;
            try {
                var q = p.F1;
            }catch(e)
            {
                thrown=true;
            }
            status=status && thrown;
            t1.destruct();
            return status && countListeners()===0;
    });
    runTest("TypeSwitcher: Comprobacion de BLANK_IS_NULL en TypeSwitcher","Se comprueba BLANK_IS_NULL en TypeSwitcher",
        {
            "FIELDS":{
                "f1":{
                    "TYPE":"TypeSwitcher",
                    "BLANK_IS_NULL":true,
                    // Array Object Exists Not exists
                    "ON":[{
                        "FIELD":"ft",
                        "IS":"String",
                        "THEN":"TYPE1"
                    },
                        {
                            "FIELD":"ft",
                            "IS":"Object",
                            "THEN":"TYPE2"
                        }],
                    "ALLOWED_TYPES":{
                        "TYPE1":{
                            "TYPE":"String",

                        },
                        "TYPE2":{
                            "TYPE":"Container",
                            "BLANK_IS_NULL":true,
                            "FIELDS":{
                                "ft": {
                                    "TYPE": "String",
                                    "BLANK_IS_NULL":true
                                },
                                "f2":{
                                    "TYPE":"String"
                                }
                            }
                        }
                    }

                }
            }
        },
    function (def) {

    });

    runTest("Array: Comprobaciones de Array (1)",
        "Comprobaciones basicas de array, incluyendo gestores de eventos,chequeos de errores,etc",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Array",
                    "ELEMENTS": {"TYPE": "String", "MINLENGTH": 2}
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
          def
        );
        var firstStatus = (t1.f3 === null);
        var nErrors = 0;
        var nChanges = 0;

        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges++
        });
        var nExcp = 0;
        try {
            t1.f3 = ["u"];
        } catch (e) {
            nExcp++;
        }
        var secondStatus = ( nChanges == 1 && nExcp == 1);
        t1.f3 = ["uu"];
        var thirdStatus = (t1.f3.length == 1 && t1.f3[0] == "uu" && nChanges == 2);
        t1.destruct();
        return firstStatus && secondStatus && thirdStatus && countListeners() == 0;
    }, true);

    runTest("Array: Comprobaciones de Array (2)",
        "Comprobaciones del funcionamiento correcto de los metodos de Array",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Array",
                    "ELEMENTS": {"TYPE": "String", "MINLENGTH": 2}
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
           def
        );
        var firstStatus = (t1.f3 === null);
        var nErrors = 0;
        var nChanges = 0;

        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges++
        });
        var nExcp = 0;
        try {
            t1.f3 = [];
            t1.f3.push("a");
        } catch (e) {
            nExcp++;
        }
        var secondStatus = (t1.f3.length == 1 && nChanges == 2 && nExcp == 1);
        t1.f3.push("aaa");
        var thirdStatus = (t1.f3.length == 2 && nChanges == 3 && nExcp == 1);
        t1.f3.shift();
        var fourthStatus = (t1.f3.length == 1 && nChanges == 4);
        t1.destruct();
        return firstStatus && secondStatus && thirdStatus && fourthStatus && countListeners() == 0;
    }, true);

    // Mismo test anterior, pero con objetos dentro del array.
    runTest("Array: Comprobaciones de Array (3)",
        "Mismo test anterior, con elementos complejos de tipo Container.Se comprueban tambien los paths",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Array",
                    "ELEMENTS": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "sf1": {"TYPE": "String", "MINLENGTH": 2},
                            "sf2": {"TYPE": "Integer"}
                        }
                    }
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
           def
        );

        var nErrors = 0;
        var nChanges = 0;

        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges++
        });
        var nExcp = 0;
        try {
            t1.f3 = [{sf1: "a", sf2: 15}];
        } catch (e) {
            nExcp++;
        }
        var secondStatus = ( nChanges == 1 && nExcp == 1);
        t1.f3 = [{sf1: "aaa", sf2: 20}];
        var thirdStatus = (t1.f3.length == 1 && nChanges == 2 && nExcp == 1);
        var curPath = t1.f3[0]["*sf1"].__getFieldPath();
        var fourthStatus = (curPath == "/f3/0/sf1");
        t1.destruct();
        return secondStatus && thirdStatus && fourthStatus && countListeners() == 0;
    }, true);

    runTest("Array: Comprobaciones de Array (4)",
        " Se comprueba que cuando se hace getValue() de un tipo, y se sobreescribe el tipo,\n" +
        "  no se reciben nuevos eventos.\n" +
        "  Supongamos un Array con valor [2,3,4]. Si alguien asigna a \"obj\" un getValue() de eso, se queda\n" +
        "  con ese array.Si al tipo Array se le asigna un nuevo valor ([5,6,7]), obj NO es notificado.\n" +
        "  Es decir, obj esta escuchando a su propia copia, no al BaseType.",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Array",
                    "ELEMENTS": {
                        "TYPE": "String"
                    }
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
            def
        );

        var nErrors = 0;
        var nChanges = 0;

        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges++
        });

        t1.f3=["aa","bb"];
        // Generamos una copia eventizada, para escuchar cambios.
        var h={};
        h.q=t1["*f3"].getValue();
        Siviglia.Path.eventize(h,"q");
        var nRefChanges=0;
        h["*q"].addListener("CHANGE",function(){nRefChanges++;});

        // Mientras siga siendo el mismo objeto, se deben seguir recibiendo eventos:
        t1.f3.push("cc");
        var status=(nRefChanges==1 && nChanges==2);

        // Ahora se cambia el valor completamente.Esto no deberia generar eventos en h.q
        t1.f3=["dd","ee","ff"];
        status = status && (nRefChanges==1 && nChanges==3);

        // Scomprobacion de path.
        var fPath=t1.f3["*0"].__getFieldPath();

        status=status && t1.f3["*0"].__getFieldPath()=="/f3/0";


        t1.destruct();
        h.__destroy__();


        status = status && countListeners()==0;

        // Se limpian manualmente los listeners.
        Siviglia.Dom.existingListeners=[];




        return status && countListeners() == 0;
    }, true);
    runTest("Array: Comprobaciones de Array(5)", "Se comprueba el funcionamiento de BLANK_IS_NULL",{
        "FIELDS":{
                    "f3":
                    {
                        "TYPE":"Array",
                        "BLANK_IS_NULL":true,
                        "ELEMENTS":{
                            "TYPE":"String",
                        }
                    }
                }
        },
        function (def) {
            var t1 = new Siviglia.model.BaseTypedObject(
                def
            );

            t1.f3=[];
            var status=t1["*f3"].__hasOwnValue()===false && t1["*f3"].__isEmptyValue([]);
            t1["*f3"].setValue(null);
            status=status && t1["*f3"].__hasOwnValue()===false;
            t1.f3=["aa"];
            status=status && t1["*f3"].__hasOwnValue()!==false;
            t1.destruct();
            return status;
        }
    )


    runTest("Array: Comprobaciones de Array (6)",
        "Se comprueba el funcionamiento del borrado de elementos de un array,con TypeSwitchers y Containers",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Array",
                    "ELEMENTS": {
                        "TYPE": "TypeSwitcher",
                        "TYPE_FIELD":"TYPE",
                        "ALLOWED_TYPES":{
                            "T1":{
                                "TYPE":"Container",
                                "FIELDS":{
                                    "TYPE":{
                                        "TYPE":"String",
                                        "FIXED":"T1"
                                    }   ,
                                    "CAMPO":{
                                        "TYPE":"String"
                                    }
                                }
                            },
                            "T2":{
                                "TYPE":"Container",
                                "FIELDS":{
                                    "TYPE":{
                                        "TYPE":"String",
                                        "FIXED":"T2"
                                    }   ,
                                    "CAMPO2":{
                                        "TYPE":"String"
                                    }
                                }
                            },
                            "T3":{
                                "TYPE":"Container",
                                "FIELDS":{
                                    "TYPE":{
                                        "TYPE":"String",
                                        "FIXED":"T3"
                                    }   ,
                                    "CAMPO3":{
                                        "TYPE":"String"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        function (def) {
            var t1 = new Siviglia.model.BaseTypedObject(
                def
            );
            var f=t1["*f3"];
            var nErrors = 0;
            var nChanges = 0;

            f.addListener("CHANGE", null, function () {
                nChanges++
            });
            var a1={"TYPE":"T1","CAMPO":"abcde"};
            var a2={"TYPE":"T2"};
            var a3={"TYPE":"T3","CAMPO3":"jklm"};
            f.setValue([a1,a2,a3]);

            f.splice(1,1);

            var status=f[0].CAMPO==="abcde" && f[1].CAMPO3==="jklm" && f.length===2;

            // El splice ha movido el elemento que antes estaba en 2, a la posicion 1. Para que esto funcione, ha
            // habido que crear un nuevo typeswitcher en 1, con el valor del typeswitcher que habia en 2.

            // Lo importante, es que ese valor siga apuntando al mismo objeto, de forma que sigue siendo el mismo
            // valor referenciado por a3. Asi que si cambiamos a3, lo que hay en f[1] tiene que cambiar tambien.
            // NOTA: LO ANTERIOR NO ES POSIBLE: EL TYPESWITCHER QUE HABIA EN 2, EVENTIZO EL OBJETO a3 PARA QUE APUNTARA A ÉL.
            // SI LUEGO ESE OBJETO PASA A SER EL VALOR DEL TYPESWITCHER QUE SE CREA EN 1, SOLO HABRIA 2 POSIBILIDADES:
            // 1) RE-EVENTIZAR a3 PARA QUE AHORA APUNTE AL TYPESWITCHER NUEVO. ESTO NO ES POSIBLE, PORQUE NADIE GARANTIZA
            // QUE EL TYPESWITCHER QUE HAY EN 2 (Y QUE LO EVENTIZÓ INICIALMENTE), VAYA A DESAPARECER: LO SIGUE USANDO. SERIA
            // UN VALOR COMPARTIDO
            // 2) NO RE-EVENTIZAR : a3 SEGUIRIA APUNTANDO A TYPESWITCHER 2, QUE VA A SER DESTRUIDO.
            // ASI QUE NO QUEDA MAS REMEDIO QUE HACER UNA COPIA!


            // a3.CAMPO3="JORGITO";
            a3=f[1];
            a3.CAMPO3="JORGITO";



           status= status && f[1].CAMPO3==="JORGITO";

            t1.destruct();

            return status && countListeners() == 0;
        }, true);

    runTest("Array: Comprobaciones de Array (7)", "Utilizacion de arrays planos js. Es importante ver que, para vincular un array js con un array controlado por un tipo, es necesario sobreescribir la variable inicial, con el valor devuelto por setValue(), o, en caso de usar el constructor de tipo para establecer el valor, "+
        "reasignar la variable a lo que devuelva getValue().<br>En el ejemplo, hay 2 lineas que parecen equivalentes:<br> t1.f3=arr;<br>arr=t1.f3<br>" +
            "pero no lo son: al asignarse t1.f3, se construye un proxy alrededor del valor. Cuando se obtiene el valor de nuevo, t1.f3 devuelve el proxy, no el array original."+
        " por lo que en la primera linea, arr es un array javascript normal.Tras la segunda linea, arr es un proxy a ese array.",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Array",
                    "ELEMENTS": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "TYPE": {
                                "TYPE": "String",
                                "FIXED": "T1"
                            },
                            "CAMPO": {
                                "TYPE": "String"
                            },
                            "CAMPO2": {
                                "TYPE": "String",
                                "MAXLENGTH":2
                            }
                        }
                    },
                }
            }
        },
        function (def) {
            var t1 = new Siviglia.model.BaseTypedObject(
                def
            );
            var arr=[{"TYPE":"T1","CAMPO":"abcde"},{"TYPE":"T2","CAMPO":"abcde"},{"TYPE":"T3","CAMPO":"abcde"}];

            // Importante!! Parece que las dos lineas siguientes no van a cambiar lo que hay en arr, pero sí que
            // lo van a hacer!
            t1.f3=arr;
            arr=t1.f3;

            var nChanges=0;
            t1["*f3"].addListener("CHANGE",function(evName,params){
                nChanges++;
            });
            arr.push({"TYPE":"T5","CAMPO":"qqq"});
            var status=(nChanges===1 && t1.f3.length===4);
            var excpThrown=false;
            try{
                // Debe dar excepcion, ya que CAMPO2 tiene un MAXLENGTH
                arr.push({"TYPE":"T6","CAMPO2":"ssssss"})
            }catch(e)
            {
                excpThrown=true;
            }
            status=status && excpThrown===true;

            t1.destruct();

            return status && countListeners() == 0;
        }, true);

    runTest("Array: Comprobaciones de Array (8)", "Tests de comportamiento de Arrays, cuando se usan referencias.Se crea un basetypedobject con 2 arrays,"+
            "y se comprueba que al asignar uno al otro, se crea una copia.",
        {
            "FIELDS": {
                "field1": {
                    "TYPE": "Array",
                    "ELEMENTS": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "F1": {
                                "TYPE": "String"
                            }
                        }
                    }
                },
                "field2": {
                    "TYPE": "Array",
                    "ELEMENTS": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "F1": {
                                "TYPE": "String",
                                "MAXLENGTH":3
                            }
                        }
                    }
                }
            }
        },
        function (def) {

            var t1 = new Siviglia.model.BaseTypedObject(
                def
            );
            var arr=[{"F1":"ab"},{"F1":"cdefgth"},{"F1":"yy"},{"F1":"uu"}];
            var f1_changes=0;
            var f2_changes=0;

            t1["*field1"].addListener("CHANGE",null,function(evName,param){
                f1_changes++;
            })
            t1["*field2"].addListener("CHANGE",null,function(evName,param){
                f2_changes++;
            })
            t1.field1=arr;
            var status=f1_changes===1;
            var exceptionThrown=false;
            try {
                t1.field2 = t1.field1;
            }catch(e)
            {
                exceptionThrown=true;
            }

            status = status && exceptionThrown && f1_changes==1 && f2_changes==1;

            t1.destruct();
            return status && countListeners() == 0;
        }, true);


    runTest("Dictionary: Comprobaciones de Referencias a Dictionary", "Test equivalente al anterior, pero usando Dictionarys en vez de Arrays.",
        {
            "FIELDS": {
                "field1": {
                    "TYPE": "Dictionary",
                    "VALUETYPE": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "F1": {
                                "TYPE": "String"
                            }
                        }
                    }
                },
                "field2": {
                    "TYPE": "Dictionary",
                    "VALUETYPE": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "F1": {
                                "TYPE": "String",
                                "MAXLENGTH":3
                            }
                        }
                    }
                }
            }
        },
        function (def) {

            var t1 = new Siviglia.model.BaseTypedObject(
                def
            );
            var dict={"a":{"F1":"ab"},"b":{"F1":"cdefgth"},"c":{"F1":"yy"},"d":{"F1":"uu"}};
            var f1_changes=0;
            var f2_changes=0;

            t1["*field1"].addListener("CHANGE",null,function(evName,param){
                f1_changes++;
            })
            t1["*field2"].addListener("CHANGE",null,function(evName,param){
                f2_changes++;
            })
            t1.field1=dict;
            var status=f1_changes===1;
            var exceptionThrown=false;
            try {
                t1.field2 = t1.field1;
            }catch(e)
            {
                exceptionThrown=true;
            }

            status = status && exceptionThrown && f1_changes==1 && f2_changes==1;

            var d1s=t1.field1;

            d1s["x"]={"F1":"ttt"};
            status = status && f1_changes===2;
            delete d1s["a"];
            status=status && f1_changes===3 && typeof(t1.field1.a)==="undefined";

            var d2s=t1.field2;
            exceptionThrown=false;
            try{
                d2s["x"]={"F1":"xxxxxxxx"}
            }catch(e)
            {
                exceptionThrown=true;
            }

            status=status && f2_changes===2;

            t1.destruct();

            return status && countListeners() == 0;
        }, true);


    runTest("Container: Container inicializado a partir de objeto plano javascript",
        "Se comprueba el funcionamiento de container inicializado a partir de un objeto plano javascript",
        {
            "FIELDS": {
                            "F1":{
                                "TYPE":"Container",
                                "FIELDS":{
                                    "TYPE":{
                                        "TYPE":"String",
                                        "FIXED":"T1"
                                    }   ,
                                    "CAMPO":{
                                        "TYPE":"String"
                                    },
                                    "CAMPO2":{
                                        "TYPE":"String"
                                    }
                                }
                            }
                    }
        },
        function (def) {
            var t1 = new Siviglia.model.BaseTypedObject(
                def
            );
            var a={};
            t1.F1=a;
            var nChanges=0;
            t1.F1["*CAMPO2"].addListener("CHANGE",function(ev,params){nChanges++;})
            a.CAMPO2="lala";
            t1.destruct();
            return nChanges==1;
        }, true);

    runTest("Enum: Comprobaciones de Enum (1)",
        "Comprobaciones simples del tipo Enum",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Enum",
                    "VALUES": ["Value1", "Value2", "Value3"],
                    "DEFAULT": "Value3"
                }
            }
        },
        function (def) {

        var t1 = new Siviglia.model.BaseTypedObject(def);

        var nChanges = 0;
        var errored=0;
        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges++
        });
            t1["*f3"].addListener("ERROR", null, function () {
                    errored++;
            });
        var nExcp = 0;
        try {
            t1.f3 = "Value4";
        } catch (e) {
            nExcp++;
        }
        var secondStatus = (errored==1 && nChanges == 0 && nExcp == 1);
        t1.f3 = "Value1";
        var thirdStatus = (t1.f3==0 && t1["*f3"].getLabel() == "Value1" && nChanges == 1 && nExcp == 1);
        t1.f3 = 2;
        var fourthStatus = (t1["*f3"].getLabel() == "Value3" && nChanges == 2 && nExcp == 1);

        t1.destruct();
        return secondStatus && thirdStatus && fourthStatus && countListeners() == 0;
    }, true);
    runTest("Integer: Comprobaciones de Integer",
        "Comprobaciones simples del tipo Integer",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Integer",
                    "MIN": 10,
                    "MAX": 20,
                    "DEFAULT": 15
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
           def
        );
        var nChanges = 0;
            var nErrors = 0;
        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges++

        });
        t1["*f3"].addListener("ERROR", null, function () {
            nErrors++
        });
        var nExcp = 0;

        var firstStatus = (t1.f3 == 15);
        try {
            t1.f3 = 8;
        } catch (e) {
            nExcp++;
        }
        var secondStatus = (nChanges == 0 && nExcp == 1 && nErrors==1);
        try {
            t1.f3 = 22;
        } catch (e) {
            nExcp++;
        }
        var secondStatus = (nChanges == 0 && nExcp == 2 && nErrors==2);
        t1.f3 = 16;
        var thirdStatus = (t1.f3 == 16 && nChanges == 1);


        t1.destruct();
        return firstStatus && secondStatus && thirdStatus && countListeners() == 0;
    }, true);
    runTest("String: Comprobaciones de String",
        "Comprobaciones de String, incluyendo regexes",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "String",
                    "MINLENGTH": 2,
                    "MAXLENGTH": 7,
                    "DEFAULT": "Valido"
                },
                "f4": {
                    "TYPE": "String",
                    "REGEXP": "/aa/"
                },

            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
            def
        );
        var nChanges = 0;
        var nErrors=0;
        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges++
        });
            t1["*f3"].addListener("ERROR", null, function () {
                nErrors++
            });
        t1["*f4"].addListener("CHANGE", null, function () {
            nChanges++
        });
            t1["*f4"].addListener("ERROR", null, function () {
                nErrors++
            });
        var nExcp = 0;
        var firstStatus = (t1.f3 == "Valido");
        try {
            t1.f3 = "a"
        } catch (e) {
            nExcp++;
        }
        var secondStatus = (nErrors==1 && nChanges == 0 && nExcp == 1);
        try {
            t1.f3 = "aaaaaaaa"
        } catch (e) {
            nExcp++;
        }
        var thirdStatus = (nErrors==2 && nChanges == 0 && nExcp == 2);
        t1.f3 = "bbb";
        var fourthStatus = (t1.f3 == "bbb" && nChanges == 1 && nExcp == 2);
        try {
            t1.f4 = "ccc";
        } catch (e) {
            nExcp++;
        }
        var fifthStatus = (nErrors==3 && nChanges==1 && nExcp == 3);
        t1.f4 = "aaaa";

        var sixthStatus = (t1.f4 == "aaaa" && nChanges == 2 && nExcp == 3 && nErrors==3);


        t1.destruct();
        return firstStatus && secondStatus && thirdStatus &&
            fifthStatus && sixthStatus && countListeners() == 0;
    }, true);


    runTest("DateTime: Comprobaciones de DateTime",
        "Varias comprobaciones del funcionamiento del tipo DateTime, incluyendo limites, fechas pasadas y fechas futuras",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "DateTime",
                    "DEFAULT": "NOW"
                },
                "f4": {
                    "TYPE": "DateTime",
                    "STARTYEAR": 2000,
                    "ENDYEAR": 2020
                },
                "f5": {
                    "TYPE": "DateTime",
                    "STRICTLYPAST": true
                },
                "f6": {
                    "TYPE": "DateTime",
                    "STRICTLYFUTURE": true
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
        def
        );
        var convertDate = function (c) {
            var M = c.getMonth() + 1;
            var D = c.getDate();
            var H = c.getHours();
            var m = c.getMinutes();
            var s = c.getSeconds();
            M = (M < 10) ? ('0' + M) : M;
            D = (D < 10) ? ('0' + D) : D;
            H = (H < 10) ? ('0' + H) : H;
            m = (m < 10) ? ('0' + m) : m;
            s = (s < 10) ? ('0' + s) : s;
            return c.getFullYear() + '-' + M + '-' + D + ' ' + H + ':' + m + ':' + s;
        }
        var nChanges = 0;
        var nErrors=0;
        for(var k=3;k<=6;k++)
        {
            t1["*f"+k].addListener("CHANGE", null, function () {
                nChanges++
            });
            t1["*f"+k].addListener("ERROR", null, function () {
                nErrors++
            });
        }

        var nExcp = 0;
        var timestamp1 = t1["*f3"].getDateValue().getTime();
        var timestamp2 = (new Date()).getTime();
        var status = (timestamp2 - timestamp1 < 1000);

        try {
            t1.f4 = "1999-12-30 00:00:00";
        } catch (e) {
            nExcp++;
        }
        status = status && (nErrors==1 && nChanges == 0 && nExcp == 1);
        try {
            t1.f4 = "2021-01-01 00:00:00"
        } catch (e) {
            nExcp++;
        }
        status = status && (nErrors==2 && nChanges == 0 && nExcp == 2);
        t1.f4 = "2010-01-01 00:00:00";
        status = status && (t1.f4 == "2010-01-01 00:00:00" && nChanges == 1 && nExcp == 2);


        try {
            t1.f5 = "2050-01-01 00:00:00";
        } catch (e) {
            nExcp++;
        }
        status = status && (nErrors==3 && nExcp == 3);
        t1.f5 = "2010-01-01 00:00:00";
        status = status && (t1.f5 == "2010-01-01 00:00:00" && nChanges == 2 && nExcp == 3);

        try {
            t1.f6 = "2010-01-01 00:00:00";
        } catch (e) {
            nExcp++;
        }
        status = status && (nErrors==4 && nExcp == 4);
        t1.f6 = "2050-01-01 00:00:00";
        status = status && (t1.f6 == "2050-01-01 00:00:00" && nChanges == 3 && nExcp == 4);


        var res = convertDate(t1["*f6"].getDateValue())
        status = status && (res == t1.f6);
        t1.destruct();
        return status;
    }, true);

    runTest("Source: Source de Enum (1)",
        "Comprobacion del funcionamiento de fuentes del tipo Enum (que, por debajo utiliza sources de tipo Array)",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Enum",
                    "VALUES": ["Value1", "Value2", "Value3"],
                    "DEFAULT": "Value3"
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        var source = t1["*f3"].__getSource();
        var loaded = 0;
        var changed = 0;
        var data = null;
        source.addListener("EVENT_LOADED", null, function () {
            loaded = 1;
        });
        source.addListener("CHANGE", null, function (ev, params) {
            changed = 1;
            console.dir(params);
            data = params.value
        });
        source.fetch();
        t1.destruct();
        return loaded === 1 && changed === 1 && data.length === 3 && data[2]["LABEL"] === "Value3" && data[2]["VALUE"] === 2 && countListeners() === 0;
    }, true);


    runTest("Source: Sources de String (Array)",
        "Se comprueba el funcionamiento de un Source sobre un tipo String. Se utiliza para que, aunque un campo sea una simple String, su valor tenga que estar incluido en una fuente. Esto lo hace ligeramente parecido a los Enum, aunque en los Enum hay un valor numerico asociado, y en los Strings con source, no.",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "String",
                    "SOURCE": {
                        "TYPE": "Array",
                        "VALUES": ["Value1", "Value2", "Value3"],
                        "LABEL": "LABEL",
                        "VALUE": "LABEL"
                    }
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);

        var changed = 0;

        t1["*f3"].addListener("CHANGE", null, function (ev, params) {
            changed = 1;
        });
        var nExcp = 0;
        try {
            t1.f3="Value4";
            t1.save();

        } catch (e) {
            nExcp++;
        }
        var status = nExcp === 1;

        t1.f3="Value3";
        t1.save();
        status = status && t1.f3 === "Value3" && changed == 1;
        t1.destruct();
        return status && countListeners() == 0;
    }, true);

    runTest("Source: Sources de String (Array Path)",
        "Comprobación de sources basadas en Path, para String. Se declaran campos cuyo valor depende de un path que se basa en hasta dos otros campos del mismo objeto,y el path, una vez sustituidos los campos, apunta a arrays que contienen los valores permitidos para el campo que contiene el path.",
        {
            "FIELDS": {
                "f1": {
                    "TYPE": "String",
                    "SOURCE": {
                        "TYPE": "Array",
                        "LABEL": "Label",
                        "VALUE": "Id",
                        "DATA": [
                            {"Label": "a", "Id": "a"},
                            {"Label": "d", "Id": "d"}
                        ]
                    }
                },
                "f2": {
                    "TYPE": "String",
                    "SOURCE": {
                        "TYPE": "Array",
                        "LABEL": "Label",
                        "VALUE": "Id",
                        "DATA": [
                            {"Label": "b", "Id": "b"},
                            {"Label": "c", "Id": "c"}
                        ]
                    }
                },
                "f3": {
                    "TYPE": "Integer",
                    "SOURCE": {
                        "TYPE": "Array",
                        "LABEL": "[%Label%] [%SubLabel%]",
                        "VALUE": "Id",
                        "DATA": {
                            "a": {
                                "b": [
                                    {"Id": 1, "Label": "Primero", "SubLabel": "1º"}
                                ],
                                "c": [
                                    {"Id": 2, "Label": "Segundo", "SubLabel": "2º"}
                                ]
                            },
                            "d": {
                                "c": [
                                    {"Id": 3, "Label": "Tercero", "SubLabel": "3º"},
                                    {"Id": 4, "Label": "Cuarto", "SubLabel": "4º"}
                                ]
                            }
                        },
                        "PATH": "/{#../f1}/{#../f2}"

                    }
                }
            }
        },
        function (def) {

        var btype = new Siviglia.model.BaseTypedObject(def);
        // Primera prueba: Si el source no esta listo, deben saltar excepciones.
        var nChanges = 0;
        var nValids=0;
        var curData = null;
        var nExcp=0;
        var s = btype["*f3"].__getSource(btype);
        s.addListener("CHANGE", function (evType, data) {
            nChanges++;
            if(data.valid)
                nValids++;
            curData = data.value;
        });
        try {

            btype.f3=155;
            btype.save();

        } catch (e) {
            nExcp++;
        }
        // Aqui no puede haber aun valor.
        var status = (nExcp===1 && nChanges===1 && nValids===0 && curData===null);

        // Cambiamos uno de los valores
        btype.f1 = "a";
        // Aun no se puede establecer el valor de f3
        try {

            btype.f3=155;
            btype.save();

        } catch (e) {
            nExcp++;
        }
        status = status && (nExcp===2 && nChanges===1 && nValids===0 && curData===null);

        btype.f2 = "b";
        // En cuanto se establece el valor de f2, tiene que haberse cargado los datos del source de f3
        status = status && (nChanges===2 && nValids===1 && curData!==null && curData.length==1 && curData[0].Id==1);

        // No se puede establecer el valor de f3 a 2, solo a 1:
        try {

            btype.f3=155;
            btype.save();

        } catch (e) {
            nExcp++;
        }
        status = status && (nExcp==3);

        btype.f3=1;
        btype.save();

        // Prueba dos : el fetch deberia devolver null, porque la combinacion f1=d y f2=b no esta soportada:
            // Ademas, f3 va a quedar ahora incorrecto, ya que el source ahora es null, por lo que no puede tener
            // el valor "1"

            btype.f1 = "d";

        status = status && btype["*f3"].__isErrored()==true && (nChanges===3 && nValids===1 && curData==null);


        // Se cambia f2 a "c":
        btype.f2 = "c";

        status = status && (nChanges===4 && nValids===2 && curData!==null && curData.length==2 && curData[0].Id==3);

        btype.destruct();
        status = status && countListeners()==0;

        return status;

    }, true);


    runTest("Source: Source tipo PATH",
        "Pruebas de source de tipo path. Un campo entero apunta a otro campo, un array, que contiene los valores posibles. Se ve tambien como añadir listeners a los sources.",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "String",
                    "SOURCE":{
                        "TYPE":"Path",
                        "PATH":"#../f4/[[KEYS]]",
                        "LABEL":"LABEL",
                        "VALUE":"VALUE"
                    }
                },
                "f4": {
                    "TYPE": "Dictionary",
                    "VALUETYPE":{
                        "TYPE":"String"
                    }
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
        def
        );
        var nChanges3 = 0;
        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges3++
        });
        var nChanges4 = 0;
        t1["*f4"].addListener("CHANGE", null, function () {
            nChanges4++
        });
        var nExcp = 0;

        try{
            t1.f3="aa";
        }catch(e)
        {
            nExcp++;
        }
        var nSources=0;
        t1["*f3"].__getSource().addListener("CHANGE",null,function(){
            nSources++;
        });
        var status=t1["*f3"].__isErrored();
        t1.f4={"aa":"uno","bb":"dos"};
        // Al cambiar f4 a ese valor, f3 pasa a ser valido, asi que habra cambiado, y ya no tendra error
        status=status && t1["*f3"].__isErrored()===false && (nChanges4==1 && nChanges3===1 && nSources==1 );

        t1.save();
        status = status && (nChanges3===1 && t1.f3=="aa");
        t1.f4["cc"]="tres";
        status=status && (nChanges4==2 && nSources==2);

        t1.f3="cc";
        t1.save();
        status=status && (nChanges3===2 && t1.f3=="cc");
        t1.destruct();
        status = status && countListeners()===0;
        return status;
    }, true);

    runTest("Source: Source tipo PATH, con valores unicos",
        "Pruebas de source de tipo path, con valores unicos.Tenemos un array con tipos simples (String), cuyo source son las keys de un diccionario. Hay que asegurarse"+
        " de que en el array no hay elementos duplicados.",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Array",
                    "ELEMENTS":{
                        "TYPE":"String"
                    },
                    "SOURCE":{
                        "TYPE":"Path",
                        "PATH":"#../f4/[[KEYS]]",
                        "LABEL":"LABEL",
                        "VALUE":"VALUE",
                        "UNIQUE":true
                    }
                },
                "f4": {
                    "TYPE": "Dictionary",
                    "VALUETYPE":{
                        "TYPE":"String"
                    }
                }
            }
        },
        function (def) {
            var t1 = new Siviglia.model.BaseTypedObject(
                def
            );
            // Intentamos meter un valor en el array, cuando la fuente esta vacia..
            var thrown=false;
            try{
                t1.f3=["hola"];
            }catch(e)
            {
                thrown=true;
            }
            var status=thrown && t1["*f3"].__isErrored();
            // Se introduce ahora esa key en el diccionario:
            t1.f4={"hola":"val_hola"};
            // Y ahora, automaticamente, el campo f3 ya no deberia tener error:
            status=status && !t1["*f3"].__isErrored();

            t1.destruct();
            status = status && countListeners()===0;
            return status;
        }, true);

    runTest("Source: Source tipo Remoto",
        "Comprobacion de source de tipo remoto, mezclado con parametros en la URL que define el source. A diferencia de otros sources, los remotos solo se comprueban si el validationMode es COMPLETE, o cuando se hace el save().Hay que tener en cuenta que cuando este objeto esta vacio, y mientras no se asigna el valor que completa la URL, el source pueder llamar a onChange, pero estara marcado como invalid. Como al finalizar el test, lo que hay es una promesa que tiene que cumplirse, no estaran destruidos todos los listeners (no se ha destruido el basetypedobject) cuando se salga de la funcion. Se añade un then a la promesa, para destruir el bto con sus listeners.",
        {
            "FIELDS": {
                "f4":{
                    "TYPE":"String"
                },
                "f3": {
                    "TYPE": "Integer",
                    "SOURCE":{
                        "TYPE":"Url",
                        "URL":"/packages/Siviglia/tests/stubs/data/[%#../f4%].json",
                        "LABEL":"a",
                        "VALUE":"b"
                    }
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);

        var p=$.Deferred();
        var status=true;
        var s=t1["*f3"].__getSource();
        var nValid=0;
        var nChanged=0;
        var expectOk;
        s.addListener("CHANGE",function(ev,params){
            nChanged++;
            if(params.valid)
            {
                nValid++;
            }
            if(expectOk==1)
            {
                p.resolve(nValid===1);
            }
        });
        s.fetch();
        status=status && nChanged===1 && nValid===0;
        if(!status)
            return status;
        expectOk=1;
        t1.f4="data1";
        p.then(function(){t1.destruct()})
        return p;
    }, true);


    /*runTest("Custom: Tipo Custom Remoto, definido via Metadata",
        "Se crea un bto cuyo tipo es remoto (en este caso, un tipo metadata de String)",
        {
            "FIELDS": {
                "f4":{
                    "TYPE":"/model/reflection/Types/types/_String"
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.f4={"LABEL":"Probando"};
        var status= t1.f4.LABEL=="Probando";
        t1.destruct();
        return status;
    }, true);

    runTest("Custom: Tipo Custom Remoto: BaseType, definido via Metadata",
        "Un segundo test, cargando esta vez un objeto mucho más complejo (BaseType).Hay que fijarse en que hay que dar inicialmente un valor completo al campo, o sea, asignarle un objeto.No podemos asignar directamente un campo del objeto.Es decir, cuando se crea el bto, el campo f4 es undefined.Es por eso que no es posible hacer t1.f4.LABEL=... Hay primero que dar un valor a t1.f4 (como es normal en javascript).A partir de entonces, si se tiene acceso a los campos.",
        {
            "FIELDS": {
                "f4":{
                    "TYPE":"/model/reflection/Types/types/BaseType"
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);

        t1.f4={TYPE:"DateTime"};
        t1.f4.LABEL="Probando";
        t1.f4.TYPE.STRICTLYPAST=true;
        var status= t1.f4.LABEL=="Probando" && t1.f4["*STRICTLYPAST"].__definition.TYPE=="Boolean";
        t1.destruct();
        return status;
    }, true);*/
    runTest("TypeSwitcher: Typeswitcher extended 1",
        "Especificacion de typeswitcher basados en el tipo de dato de un cierto campo existente en el valor asignado al TypeSwicther.Esto es, en la clave 'ON' del TypeSwitcher, existe un campo FIELD",
        {
            "FIELDS":{
                "f1":{
                    "TYPE":"TypeSwitcher",
                    // Array Object Exists Not exists
                    "ON":[{
                        "FIELD":"ft",
                        "IS":"Array",
                        "THEN":"TYPE1"
                    },
                        {
                            "FIELD":"ft",
                            "IS":"Object",
                            "THEN":"TYPE2"
                        }],
                    "ALLOWED_TYPES":{
                        "TYPE1":{
                            "TYPE":"Container",
                            "FIELDS":{
                                "ft": {
                                    "TYPE": "Array",
                                    "ELEMENTS":{"TYPE": "String"}
                                },
                                "f2":{
                                    "TYPE":"Boolean"
                                }
                            }
                        },
                        "TYPE2":{
                            "TYPE":"Container",
                            "FIELDS":{
                                "ft": {
                                    "TYPE": "Container",
                                    "FIELDS":{
                                        "s1":{"TYPE":"Integer"},
                                        "s2":{"TYPE":"Integer"},

                                    }
                                },
                                "f2":{
                                    "TYPE":"String"
                                }
                            }
                        }
                    }

                }
            }

        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.setValue({"f1":{ft:["a","b","c"],"f2":true}});
        var st1=(JSON.stringify(t1.getPlainValue())=='{"f1":{"ft":["a","b","c"],"f2":true}}');
        t1.f1={"ft":{"s1":1,"s2":2}};
        st1=st1 && JSON.stringify(t1["*f1"].subNode.__definition)=='{"TYPE":"Container","FIELDS":{"ft":{"TYPE":"Container","FIELDS":{"s1":{"TYPE":"Integer"},"s2":{"TYPE":"Integer"}}},"f2":{"TYPE":"String"}}}';
        t1.f1.f2="Cambiado?";
        t1.destruct();
        return st1;
    });

    runTest("TypeSwitcher: Typeswitcher extended 2",
        "Se utiliza no solo el tipo, sino la existencia o no de un campo, para decidir el tipo del typeswitcher",
        {
            "FIELDS":{
                "f1":{
                    "TYPE":"TypeSwitcher",
                    // Array Object Exists Not exists
                    "ON":[{
                        "FIELD":"ft",
                        "IS":"Array",
                        "THEN":"TYPE1"
                    },
                        {
                            "FIELD":"aa",
                            "IS":"Present",
                            "THEN":"TYPE2"
                        }],
                    "ALLOWED_TYPES":{
                        "TYPE1":{
                            "TYPE":"Container",
                            "FIELDS":{
                                "ft": {
                                    "TYPE": "Array",
                                    "ELEMENTS":{"TYPE": "String"}
                                },
                                "f2":{
                                    "TYPE":"Boolean"
                                }
                            }
                        },
                        "TYPE2":{
                            "TYPE":"Container",
                            "FIELDS":{
                                "aa": {
                                    "TYPE": "Integer",
                                },
                                "f2":{
                                    "TYPE":"String"
                                }
                            }
                        }
                    }

                }
            }

        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.setValue({"f1":{ft:["a","b","c"],"f2":true}});
        var st1=(JSON.stringify(t1.getPlainValue())=='{"f1":{"ft":["a","b","c"],"f2":true}}');
        t1.f1={aa:1};
        st1=st1 && JSON.stringify(t1["*f1"].subNode.__definition)=='{"TYPE":"Container","FIELDS":{"aa":{"TYPE":"Integer"},"f2":{"TYPE":"String"}}}';
        t1.destruct();
        return st1;
    });

    runTest("TypeSwitcher: Typeswitcher extended 3",
        "Especificacion de typeswitcher basados en el tipo de dato asignado al typeswitcher (y no de un cierto campo, como hace 2 tests).Esto es, en la clave 'ON' del TypeSwitcher, NO existe un campo FIELD",
        {
            "FIELDS":{
                "f1":{
                    "TYPE":"TypeSwitcher",
                    // Array Object Exists Not exists
                    "ON":[{
                        "IS":"Array",
                        "THEN":"TYPE1"
                    },
                        {
                            "IS":"String",
                            "THEN":"TYPE2"
                        }],
                    "ALLOWED_TYPES":{
                        "TYPE1":{
                            "TYPE":"Array",
                            "ELEMENTS":{
                                "TYPE": "String"
                            }
                        },
                        "TYPE2":{
                            "TYPE":"String"
                        }
                    }

                }
            }

        },
        function (def) {

        var t1 = new Siviglia.model.BaseTypedObject(def);

        t1.setValue({"f1":"Hola?"});
        var st1=(JSON.stringify(t1.getPlainValue())=='{"f1":"Hola?"}');

        t1.setValue({"f1":["a","b","c"]});
        st1=st1 && JSON.stringify(t1["*f1"].subNode.__definition)=='{"TYPE":"Array","ELEMENTS":{"TYPE":"String"}}';
        t1.destruct();
        st1=st1 && countListeners()==0;
        return st1;
    });
    runTest("Array: Array Serialization",
        "Se prueba la serializacion a json (getPlainValue), combinando diccionario/container/array",
        {
            "FIELDS": {
                "f2":{
                    "TYPE":"Dictionary",
                    "VALUETYPE":{

                        "TYPE": "Container",
                        "FIELDS":
                            {
                                "f4": {
                                    "TYPE": "Array",
                                    "ELEMENTS": {
                                        "TYPE": "Container",
                                        "FIELDS": {
                                            "sf1": {"TYPE": "String", "MINLENGTH": 2},
                                            "sf2": {"TYPE": "Integer"}
                                        }
                                    }
                                }
                            }

                    }
                }
            }
        },
        function (def) {

        // Se crea una primera instancia, y se le asigna un valor:
        var t1 = new Siviglia.model.BaseTypedObject(def);
        var v=[{sf1:"aa",sf2:5},{sf1:"bb",sf2:15},{sf1:"cc",sf2:25}];
        t1.f2={aa:{f4:v}};

        var vv=JSON.stringify(t1.getPlainValue());
        var asserts=(vv==="{\"f2\":{\"aa\":{\"f4\":[{\"sf1\":\"aa\",\"sf2\":5},{\"sf1\":\"bb\",\"sf2\":15},{\"sf1\":\"cc\",\"sf2\":25}]}}}");
        t1.destruct();
        return asserts && countListeners()==0;
    });

    runTest("Container: Accesos a traves de paths",
    "Se comprueba el acceso correcto a campos especificados por paths.ESTE EJEMPLO ES IMPORTANTE, porque en la version por el lado del servidor, NO ES NECESARIO dar un valor al container, para poder acceder a sus campos. Esto se hace asi, porque, mientras en PHP esto es codigo valido: $a['q']='hola''; el equivalente javascript, a.q='hola' da error, ya que hay que inicializar 'a' a un objeto.Por mantener la misma semantica que el lenguaje original, la libreria de tipos exige, antes de acceder a los campos, que el container padre tenga valor.",
        {
            "TYPE":"Container",
        "FIELDS": {
            "one": {"TYPE": "String", "MINLENGTH": 2, "MAXLENGTH": 10},
            "two": {"TYPE": "String", "DEFAULT": "Hola"}
        }
        },
    function (def) {
        var cnt = Siviglia.types.TypeFactory.getType({"fieldName":"a","path":"/"},def,null,null);
        var p=cnt.__getFieldPath();
        var status=(p==="/a");
        cnt.setValue({});
        status = status && "/a/one"===cnt["*one"].__getFieldPath();
        cnt.destruct();
        return status;
    });

    runTest("Container: Comprobaciones de campos dirty",
    "Diferentes comprobaciones de que los campos se establecen a dirty correctamente",
        {
            "TYPE":"Container",
        "FIELDS":{
        "one":{"TYPE":"String","REQUIRED":true},
        "two":{"TYPE":"String","REQUIRED":true},
        "state":{"TYPE":"State","VALUES":["E1","E2","E3"],"DEFAULT":"E1"}
    },
    'STATES' : {
        'STATES' : {
        'E1' : {
        'FIELDS' : {'EDITABLE' : ['one','two']}
    },
    'E2' : {
        'ALLOW_FROM':["E1"],
        'FIELDS' : {'EDITABLE' : ['two','three']}
    },
    'E3' : {
        'ALLOW_FROM':["E2"],
        'FINAL':true,
        'FIELDS' : {'REQUIRED' : ['three']}}
    },
    'FIELD' : 'state'
    }
    },
        function (def) {
            var cnt = Siviglia.types.TypeFactory.getType({"fieldName":"a","path":"/"},def,null,null);
            var status=cnt.isDirty()===false && cnt.__hasOwnValue()===false;
            cnt.setValue({"one":"aa","two":"bbb"});
            status = status && cnt["*one"].isDirty();
            var dFields=cnt.getDirtyFields();
            var keys=[];
            for(var k=0;k<dFields.length;k++)
                keys.push(dFields[k].__getFieldName());
            status=status && keys.length==2;
            status=status && keys.indexOf("one")>=0 && keys.indexOf("two")>=0;
            cnt.destruct();
            return status;
        }
    );

    runTest("Container: Comprobaciones de campos dirty anidados",
            "Se comprueba que los campos dirty son asignados cada uno a su controller, con los paths correctos",
            {
                "TYPE":"Container",
                "FIELDS":{
                    "one":{"TYPE":"String","REQUIRED":true},
                    "two":{"TYPE":"String","REQUIRED":true},
                    "state":{"TYPE":"State","VALUES":["E1","E2","E3"],"DEFAULT":"E1"},
                    "inner":{
                        "TYPE":"Container",
                        "REQUIRED":true,
                        "FIELDS":{
                            "one":{"TYPE":"String","REQUIRED":true},
                            "two":{"TYPE":"String","REQUIRED":true},
                            "state":{"TYPE":"State","VALUES":["E1","E2","E3"],"DEFAULT":"E1"}
                        },
                        'STATES' : {
                            'STATES' : {
                                'E1' : {
                                    'FIELDS' : {'EDITABLE' : ['one','two']}
                                },
                                'E2' : {
                                    'ALLOW_FROM':["E1"],
                                    'FIELDS' : {'EDITABLE' : ['two','three']}
                                },
                                'E3' : {
                                    'ALLOW_FROM':["E2"],
                                    'FINAL':true,
                                    'FIELDS' : {'REQUIRED' : ['three']}}
                            },
                            'FIELD' : 'state'
                        }
                    }
                },
                'STATES' : {
                    'STATES' : {
                        'E1' : {
                            'FIELDS' : {'EDITABLE' : ['one','two','inner']}
                        },
                        'E2' : {
                            'ALLOW_FROM':["E1"],
                            'FIELDS' : {'EDITABLE' : ['two','three']}
                        },
                        'E3' : {
                            'ALLOW_FROM':["E2"],
                            'FINAL':true,
                            'FIELDS' : {'REQUIRED' : ['three']}}
                    },
                    'FIELD' : 'state'
                }
        },
        function (def) {
            var cnt = Siviglia.types.TypeFactory.getType({"fieldName":"a","path":"/"},def,null,null);
            var status=cnt.isDirty()===false && cnt.__hasOwnValue()===false;


            // Asignamos un campo del container interno.
            // Esto tiene que hacer que ambos containers se pongan a sucio, pero ninguno de los dos tiene valor
            cnt.setValue({"inner":{"one":"aa","two":"zzz"},"one":"aaa","two":"bbb"});
            status = status && cnt.isDirty() && cnt["*inner"].isDirty();

            // Ademas, ambos campos tienen que tener campos sucios:
            // Desde el container externo, es el container interno el que esta sucio.
            var dFields=cnt.getDirtyFields();
            var foundInner=false;
            for(var k=0;k<dFields.length;k++){
                    if(dFields[k].__getFieldName()=="inner")
                        foundInner=true;
                }
            status = status && foundInner && 3===dFields.length;


            // Desde el container interno, es el campo "/one" el que esta sucio.
            dFields=cnt["*inner"].getDirtyFields();
            var foundOne=false;
            var foundTwo=false;
            for(var k=0;k<dFields.length;k++){
                if(dFields[k].__getFieldName()=="one")
                    foundOne=true;
                    if(dFields[k].__getFieldName()=="two")
                    foundTwo=true;
                }
            status=status && dFields.length==2 && foundOne && foundTwo;
            cnt.destruct();
            return status;
        });

        runTest(
            "Container: Comprobaciones basicas de estado",
            "En este test, se introducen muchas aserciones sobre la API basica de estado, por no crear un test separado por cada cosa a probar. De nuevo, aqui hay una diferencia grande con respecto al servidor: Hay que darle un valor al container para poder preguntar por su estado.",
            {
                "TYPE":"Container",
                "FIELDS":{
                    "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":10},
                    "two":{"TYPE":"String","DEFAULT":"Hola"},
                    "three":{"TYPE":"String"},
                    "four":{"TYPE":"String"},
                    "state":{"TYPE":"State","VALUES":["E1","E2","E3"],"DEFAULT":"E1"}
                },
                'STATES' : {
                    'STATES' : {
                        'E1' : {
                            'FIELDS' : {'EDITABLE' : ['one','two']}
                        },
                        'E2' : {
                            'ALLOW_FROM':["E1"],
                            'FIELDS' : {'EDITABLE' : ['two','three']}
                        },
                        'E3' : {
                            'ALLOW_FROM':["E2"],
                            'FINAL':true,
                            'FIELDS' : {'REQUIRED' : ['three']}}
                    },
                    'FIELD' : 'state'
                }
            },
            function (def) {
                /* Aqui se van a comprobar todas las funcionalidades basicas de estado. Se va a hacer en un solo test para
     no repetir continuamente la misma definicion, alargando este fichero. */
                var cnt = Siviglia.types.TypeFactory.getType({"fieldName":"a","path":"/"},def,null,null);
                // Se asigna un valor vacio para poder tener acceso a los campos.
                cnt.setValue({});
                var st=cnt.getStateDef();
                var status= st!==null;

                    status=status && "E1"===st.getCurrentStateLabel();
                    status = status && "state"===st.getStateField();
                    status = status && true===st.hasStates();
                    status = status && JSON.stringify(def["STATES"])===JSON.stringify(st.getStates());
                    status = status && "E1"===st.getDefaultState();
                    status = status && cnt["*state"]===st.getStateType();
                    status = status && 0===st.getStateId("E1");
                    status = status && 2===st.getStateId("E3");
                    status = status && false===st.isFinalState("E1");
                    status = status && true===st.isFinalState("E3");
                    status = status && "E1"===st.getStateLabel(0);
                    status = status && "E3"===st.getStateLabel(2);
                    status = status && "E1"===st.getCurrentStateLabel();
                    // Nos saltamos por ahora los tests de checkState.
                    status = status && true===st.isEditable("one");
                    status = status && true===st.isEditable("two");
                    // Los metodos de isRequired y isFixed, en realidad usan los siguientes metodos. Testear estos metodos es
                    // "equivalente" a testear los otros.
                    status = status && true===st.isEditableInState("one","E1");
                    status = status && true===st.isEditableInState("two","E1");
                    status = status && false===st.isEditableInState("one","E2");
                    // Comprobamos que tambien funcionan con paths
                    status = status && false===st.isEditableInState("/one","E2");
                    status = status && true===st.isEditableInState("state","E2");
                    status = status && false===st.isRequiredForState("three","E1");
                    status = status && true===st.isRequiredForState("three","E3");
                    status = status && false===st.isRequiredForState("one","E1");
                    status = status && false===st.isRequiredForState("three","E1");
                    // Por ahora, no vamos a soportar campos FIXED. No esta clara su utilidad, y su especificacion es diferente
                    // a EDITABLE y REQUIRED, lo que añade una ligera complicacion.
                    //status = status && true,st.isFixedInState("four","E2");
                    //status = status && false,st.isFixedInState("four","E1");
                    // Todos los metodos anteriores, han hecho uso de existsFieldInStateDefinition, por lo que no lo probamos.

                    status = status && false===st.isEditableInState("one","E2");
                    // El siguiente metodo descriptivo es:
                    status = status && null===st.getStateTransitions(0);
                    var st1=st.getStateTransitions(1);
                    status = status && st1.length==1 && st1[0]==0;
                    var st2=st.getStateTransitions(2);
                    status = status && st2.length==1 && st2[0]==1;
                    // Siguiente : canTranslateTo
                    status = status && true===st.canTranslateTo(1);
                    status = status && false===st.canTranslateTo(2);
                    // Siguiente: getRequiredFields
                    status = status && st.getRequiredFields("E1").length===0;
                    var reqFields=st.getRequiredFields("E3");
                    status = status && "three"===reqFields[0];
                    cnt.destruct();
                    return status;
            }
        );
    runTest(
        "Container: Comprobaciones funcionales de estado",
        "Se ejecutan operaciones dependientes de estado, para comprobar que campos requeridos, transiciones posibles, etc, se respetan.",
        {
            "TYPE":"Container",
            "FIELDS":{
                "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":10},
                "two":{"TYPE":"String","DEFAULT":"Hola"},
                "three":{"TYPE":"String"},
                "four":{"TYPE":"String"},
                "state":{"TYPE":"State","VALUES":["E1","E2","E3"],"DEFAULT":"E1"}
            },
            'STATES' : {
                'STATES' : {
                    'E1' : {
                        'FIELDS' : {'EDITABLE' : ['one','two']}
                    },
                    'E2' : {
                        'ALLOW_FROM':["E1"],
                        'FIELDS' : {'EDITABLE' : ['two','three']}
                    },
                    'E3' : {
                        'ALLOW_FROM':["E2"],
                        'FINAL':true,
                        'FIELDS' : {'REQUIRED' : ['three']}}
                },
                'FIELD' : 'state'
            }
        },
        function (def) {

            var cnt = Siviglia.types.TypeFactory.getType({"fieldName": "a", "path": "/"}, def, null, null);
            // Se asigna un valor vacio para poder tener acceso a los campos.
            // Estamos en el estado inicial, que debe ser "E1", por ser el valor por defecto.
            // En este estado, "one" y "two" son editables:
            cnt.setValue({"one":"AAA","two":"BBB"});
            // Hasta aqui no deben haber saltado excepciones.De hecho, por debajo deberia haberse completado el estado,
            // Ahora si que deberia saltar una excepcion, al modificar un campo que no esta definido como editable:
            var thrown=false;
            var result=true;
            try {
                cnt.three = "CCC";
            }catch(e)
            {
                thrown=true;
                result=result && e.path==="/a/three" && (e.type=="BaseTypedException" && e.code==Siviglia.model.BaseTypedException.ERR_NOT_EDITABLE_IN_STATE);
            }
            result=result && thrown;

            // Ahora se comienza un cambio de estado.Aqui se va a probar un cambio de estado realizado a base de
            // asignar campos uno a uno, en vez de darle valor a todo el container.Eso tendra que hacerse en una prueba posterior.
            cnt.state="E2";
            // Intentamos editar de nuevo el campo "one", pero no es editable en este estado.
            thrown=false;
            try {
                cnt.one = "CCC";
            }catch(e)
            {
                thrown=true;
                result=result && (e.type=="BaseTypedException" && e.code==Siviglia.model.BaseTypedException.ERR_NOT_EDITABLE_IN_STATE);
            }
            result=result && thrown;

            // Ahora, se va a intentar cambiar al siguiente estado, E3, pero deberia dar una excepcion, ya que
            // el campo three es requerido en el estado E3:
            thrown=false;
            try {
                cnt.state="E3";
            }catch(e)
            {
                // Ahora mismo, hay 3 campos con errores: one, (de arriba), state y three (que es requerido)
                result=result && e.path==="/a/state" && (e.type=="BaseTypedException" && e.code==Siviglia.model.BaseTypedException.ERR_INVALID_STATE_TRANSITION)
                               && cnt.getErroredFields().length===3;
                thrown=true;
            }
            result=result && thrown && cnt["*state"].__isErrored()==true;

            // Rellenamos el campo faltante, y esperamos que esta vez si que se acepte el cambio de estado
            cnt.three="www";
            // Y en este punto, cnt.state debe haber completado su transicion:
            result=result && cnt.state===2;

            // Ahora estamos en un estado final. No deberia ser posible movernos de este estado, por dos motivos:
            // porque ningun otro estado lo tiene en el ALLOW_FROM, y porque es un estado final. Pero es esta
            // condicion la que debe saltar primero.
            thrown=false;
            try {
                cnt.state = "E2";
            }catch(e)
            {
                result=result && (e.type=="BaseTypedException" && e.code==Siviglia.model.BaseTypedException.ERR_CANT_CHANGE_FINAL_STATE);
                thrown=true;
            }
            cnt.destruct();
            return result && thrown;
        });
    runTest(
        "Container: Comprobaciones funcionales de estado (2)",
        "Test identico al anterior,pero los cambios de estado se provocan asignando valores completos al container, no campo a campo.",
        {
            "TYPE":"Container",
            "FIELDS":{
                "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":10},
                "two":{"TYPE":"String","DEFAULT":"Hola"},
                "three":{"TYPE":"String"},
                "four":{"TYPE":"String"},
                "state":{"TYPE":"State","VALUES":["E1","E2","E3"],"DEFAULT":"E1"}
            },
            'STATES' : {
                'STATES' : {
                    'E1' : {
                        'FIELDS' : {'EDITABLE' : ['one','two']}
                    },
                    'E2' : {
                        'ALLOW_FROM':["E1"],
                        'FIELDS' : {'EDITABLE' : ['two','three']}
                    },
                    'E3' : {
                        'ALLOW_FROM':["E2"],
                        'FINAL':true,
                        'FIELDS' : {'REQUIRED' : ['three']}}
                },
                'FIELD' : 'state'
            }
        },
        function (def) {
            var cnt = Siviglia.types.TypeFactory.getType({"fieldName": "a", "path": "/"}, def, null, null);
            var thrown=false;
            var result=true;
            try {
                cnt.setValue({
                    "state": "E1",
                    "one": "AAA",
                    "two": "BBB"
                });
            }catch(e)
            {
                thrown=true;
            }
            result=result && false===thrown;
            result=result && 0===cnt.state;
            result=result && "BBB"===cnt.two;

            // en setValue, no tiene por que haber problemas por establecer un valor incorrecto, siempre que la validacion este a NO_VALIDATION
            // Aqui, se establece un tipo incompleto (setValue)
            // Sin embargo, si que tiene que dar problemas si el tipo de validacion no es none:
            thrown=false;
            try {
                cnt.setValue({"state":"E3", "one":"AAA"}, Siviglia.types.BaseType.VALIDATION_MODE_COMPLETE);
            }catch(e)
            {
                thrown=true;
                result=result && e.path==="/a/state" && (e.type=="BaseTypedException" && e.code==Siviglia.model.BaseTypedException.ERR_INVALID_STATE_TRANSITION);
            }
            result=result && true==thrown;

            // LLamando a apply, no a setValue, podemos poner el mismo valor, aunque sea incorrecto.
            // Aqui, no se está estableciendo el campo three, que es required en ese estado.
            cnt.apply({"state":"E3","one":"AAA"},Siviglia.types.BaseType.VALIDATION_MODE_NONE);
            result=result && 2===cnt.state;
            result=result && null===cnt.three;
            result=result && "AAA"===cnt.one;
            cnt.destruct();
            return result;

        });
    /*
         COMIENZAN LOS TESTS ASOCIADOS AL FICHERO /lib/tests/model/BaseTypedObjectTest

     */
    Siviglia.Utils.buildClass(
        {
            "context": "Test",
            "classes": {
                "Definitions":{
                    "methods":{
                        getDefinition1:function()
                        {
                            return  {
                                "FIELDS":{"one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4}}
                            };
                        },
                        getDefinition2:function()
                        {
                            return {
                                "FIELDS":{
                                    "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "two":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "three":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "four":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "five":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "status":{'TYPE' : 'State',
                                        'VALUES' : [
                                            'None', 'Other', 'Another'
                                        ],
                                        'DEFAULT' : 'None'}
                                },
                                'STATES' : {
                                    'STATES' : {
                                        'None' : {
                                            'FIELDS' : {
                                                'EDITABLE' : ['one','three','five']
                                            }
                                        },
                                        'Other' : {
                                            'ALLOW_FROM':["None"],
                                            'FIELDS' : {
                                                'EDITABLE' : ['two'],
                                                'FIXED' : ['one']}
                                        },
                                        'Another' : {'FIELDS' : {
                                                'EDITABLE' : ['one'],
                                                'REQUIRED' : ['three']
                                            }
                                        },
                                        'Last' : {'FIELDS' : {
                                                'EDITABLE' : ['one'],
                                                'REQUIRED' : ['three']
                                            }
                                        }
                                    },
                                    'FIELD' : 'status',
                                    'DEFAULT' : 'None'
                                }
                            };
                        },
                        getDefinition4:function()
                        {

                            return {
                                "FIELDS":{
                                    "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "two":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "three":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "four":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "five":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "status":{'TYPE' : 'State',
                                        'VALUES' : [
                                            'None', 'Other', 'Another','Last'
                                        ],
                                        'DEFAULT' : 'None'}
                                },
                                'STATES' : {
                                    "LISTENER_TAGS":{
                                        "ONE":{"TYPE":"METHOD","METHOD":"callback_one"},
                                        "TWO":{"TYPE":"METHOD","METHOD":"callback_two"},
                                        "THREE":{"TYPE":"METHOD","METHOD":"callback_three"},
                                        "FAIL_TEST":{"TYPE":"METHOD","METHOD":"test_nok"},
                                        "TEST_OK":{"TYPE":"METHOD","METHOD":"test_ok"},
                                        "P_ONE":{"TYPE":"PROCESS","CALLBACKS":["ONE","TWO"]}
                                    },
                                    'STATES' : {
                                        'None' : {
                                            "LISTENERS":{
                                                "ON_LEAVE":{
                                                    "STATES":{"Other":["ONE"]},
                                                },
                                                "TESTS":["TEST_OK"]
                                            },
                                            'FIELDS' : {
                                                'EDITABLE' : ['one','three']
                                            }
                                        },
                                        'Other' : {
                                            'ALLOW_FROM':["None","Another"],
                                            "LISTENERS":{
                                                "ON_ENTER":{
                                                    "STATES":{
                                                        "None":["TWO"],
                                                        "Another":["THREE"]
                                                    }
                                                }
                                            },
                                            'FIELDS' : {
                                                'EDITABLE' : ['two','three'],
                                                'FIXED' : ['one']}
                                        },
                                        'Another' : {
                                            "LISTENERS":{

                                                "TESTS":["FAIL_TEST"]
                                            },
                                            'FIELDS' : {
                                                'EDITABLE' : ['one'],
                                                'REQUIRED' : ['three']
                                            }
                                        },
                                        'Last' : {

                                            "FINAL":1,
                                            "LISTENERS":{
                                                "ON_ENTER":{
                                                    "STATES":{"None":["THREE","P_ONE"]},
                                                },
                                                "TESTS":["TEST_OK"]
                                            },
                                            'FIELDS' : {
                                                'EDITABLE' : ['one'],
                                                'REQUIRED' : ['three']
                                            }
                                        }
                                    },
                                    'FIELD' : 'status',
                                    'DEFAULT' : 'None'
                                }
                            };

                        },

                        getDefinition5:function()
                        {

                            return {
                                "FIELDS":{
                                    "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "two":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "three":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "four":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "five":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "status":{'TYPE' : 'State',
                                        'VALUES' : [
                                            'None', 'Other', 'Another','Last'
                                        ],
                                        'DEFAULT' : 'None'}
                                },
                                'STATES' : {
                                    "LISTENER_TAGS":{
                                        "ONE":{"TYPE":"METHOD","METHOD":"callback_one"},
                                        "TWO":{"TYPE":"METHOD","METHOD":"callback_two","PARAMS":["set"]},
                                        "THREE":{"TYPE":"METHOD","METHOD":"callback_three"},
                                        "FAIL_TEST":{"TYPE":"METHOD","METHOD":"test_nok"},
                                        "TEST_OK":{"TYPE":"METHOD","METHOD":"test_ok"},
                                        "P_ONE":{"TYPE":"PROCESS","CALLBACKS":["ONE","TWO"]},

                                    },
                                    'STATES' : {
                                        'None' : {
                                            "LISTENERS":{
                                                "ON_LEAVE":{
                                                    "STATES":{
                                                        "Other":["ONE"],
                                                        "*":["TWO"]
                                                    },
                                                },
                                                "TESTS":["TEST_OK"]
                                            },
                                            'FIELDS' : {
                                                'EDITABLE' : ['one','three']
                                            }
                                        },
                                        'Other' : {
                                            'ALLOW_FROM':["None","Another"],
                                            "LISTENERS":{
                                                "ON_ENTER":["THREE"]
                                            },
                                            'FIELDS' : {
                                                'EDITABLE' : ['two'],
                                                'FIXED' : ['one']}
                                        },
                                        'Another' : {
                                            "LISTENERS":{
                                                "ON_ENTER":{
                                                    "STATES":{"None":["THREE","P_ONE"]},
                                                },
                                                //"TESTS":{"FAIL_TEST"}
                                            },
                                            'FIELDS' : {
                                                'EDITABLE' : ['one'],
                                                'REQUIRED' : ['three']
                                            }
                                        },
                                        'Last' : {
                                            "FINAL":1,
                                            "LISTENERS":{
                                                "TESTS":["TEST_OK"]
                                            },
                                            'FIELDS' : {
                                                'EDITABLE' : ['one'],
                                                'REQUIRED' : ['three']
                                            }
                                        }
                                    },
                                    'FIELD' : 'status',
                                    'DEFAULT' : 'None'
                                }
                            };
                        },

                        getDefinition6:function()
                        {
                            return {
                                "FIELDS":{
                                    "one":{"TYPE":"String"},
                                    "arr":{"TYPE":"Array","ELEMENTS":{
                                            "TYPE":"String"
                                        }},
                                    "dict":{"TYPE":"Container",
                                        "FIELDS":{
                                            "c1":{"TYPE":"String"},
                            "c2":{"TYPE":"Array",
                            "ELEMENTS":{
                            "TYPE":"String"
                        }
                        }
                        }
                        }
                        }
                        }

                    },
                    getDefinition7:function()
                    {
                        /**
                         * Ojo, que seven tiene un metodo get_ en SimpleTypedObject, y eight tiene un metodo
                         * check_ y process_.
                         * El metodo check_eight requiere que la cadena tenga mas de 3 caracteres.
                         */
                        return {
                            "FIELDS":{
                                "seven":{"TYPE":"String"},
                                "eight":{"TYPE":"String"}
                            }
                        };
                    },

                    // La definicion 8 es parecida a la definicion 4, pero sin
                    // restricciones, para probar la validacion
                    getDefinition8:function()
                    {
                        return {
                            "FIELDS":{
                                "one":{"TYPE":"String"},
                                "two":{"TYPE":"String"},
                                "three":{"TYPE":"String"},
                                "four":{"TYPE":"String"},
                                "five":{"TYPE":"String"},
                                "status":{'TYPE' : 'Enum',
                                    'VALUES' : [
                                        'None', 'Other', 'Another','Last'
                                    ],
                                    'DEFAULT' : 'None'}
                            },

                        };
                    },
                    getDefinition9:function()
                    {

                        return {
                            "FIELDS":{
                                "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                "two":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                "three":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                "four":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                "five":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                "status":{'TYPE' : 'State',
                                    'VALUES' : [
                                        'None', 'Other', 'Another','Last'
                                    ],
                                    'DEFAULT' : 'None'}
                            },
                            'STATES' : {
                                "LISTENER_TAGS":{
                                    "ONE":{"TYPE":"METHOD","METHOD":"callback_one"},
                                    "TWO":{"TYPE":"METHOD","METHOD":"callback_two","PARAMS":["set"]},
                                    "THREE":{"TYPE":"METHOD","METHOD":"callback_three"},
                                    "FAIL_TEST":{"TYPE":"METHOD","METHOD":"test_nok"},
                                    "TEST_OK":{"TYPE":"METHOD","METHOD":"test_ok"},
                                    "P_ONE":{"TYPE":"PROCESS","CALLBACKS":["ONE","TWO"]},
                                    "ENTERING_OK":{"TYPE":"METHOD","METHOD":"enteringState"},

                                },
                                'STATES' : {
                                    'None' : {
                                        "LISTENERS":{
                                            "ON_LEAVE":{
                                                "STATES":{
                                                    "Other":["ONE"],
                                                    "*":["TWO"]
                                                },
                                            },
                                            "TESTS":["TEST_OK"]
                                        },
                                        'FIELDS' : {
                                            'EDITABLE' : ['one','three']
                                        }
                                    },
                                    'Other' : {
                                        'ALLOW_FROM':["None","Another"],
                                        "LISTENERS":{
                                            "ON_ENTER":["THREE"]
                                        },
                                        'FIELDS' : {
                                            'EDITABLE' : ['two'],
                                            'FIXED' : ['one']}
                                    },
                                    'Another' : {
                                        "LISTENERS":{
                                            "ON_ENTER":{
                                                "STATES":{"None":["ENTERING_OK"]},
                                            },
                                            //"TESTS":{"FAIL_TEST"}
                                        },
                                        'FIELDS' : {
                                            'EDITABLE' : ['one'],
                                            'REQUIRED' : ['three']
                                        }
                                    },
                                    'Last' : {
                                        "FINAL":1,
                                        "LISTENERS":{
                                            "TESTS":["TEST_OK"]
                                        },
                                        'FIELDS' : {
                                            'EDITABLE' : ['one'],
                                            'REQUIRED' : ['three']
                                        }
                                    }
                                },
                                'FIELD' : 'status',
                                'DEFAULT' : 'None'
                            }
                        };

                    }

                }
                },
                "SimpleTypedObject": {
                    inherits:'Siviglia.model.BaseTypedObject',
                    construct:function (def) {
                        this.__one=null;
                        this.__two=null;
                        this.__three=null;
                        this.__four=null;
                        this.__five=null;
                        this.__testedOk=false;
                        this.__testedNok=false;
                        this.__enteringCalled=false;
                        this.BaseTypedObject(def);
                    },
                    methods:{
                        check_five:function(value){if(value=="five")return true;return false;},
                        process_five:function(value){return "six";},
                        callback_one:function(){this.__one="one";},
                        callback_two:function(){this.__two="set";},
                        callback_three:function(){this.__three="three";},
                        callback_four:function(){this.__four="four";},
                        test_ok:function(){this.__testedOk=true;return true;},
                        test_nok:function(){this.__testedNok=true;return false;},
                        get_seven:function(){return "seven";},
                        check_eight:function(value){return value.length>3;},
                        process_eight:function(value){return value+"##";},
                        enteringState:function(){this.__enteringCalled=true;return true;}
                    }
                }
            }
        }
    )
  var defInstance=new Test.Definitions();
    d1 = defInstance.getDefinition2();
    runTest(
        "BaseTypedObjectModel: Comprobacion simple de campo sucio",
        "Prueba de contabilizacion correcta de campos sucios",
        d1
        ,
        function (def) {
            /* Aqui se van a comprobar todas las funcionalidades basicas de estado. Se va a hacer en un solo test para
 no repetir continuamente la misma definicion, alargando este fichero. */
            var ob= new Siviglia.model.BaseTypedObject(def);
            ob.one="hola";
            var result="hola"===ob["*one"].getValue();
            result = result && true===ob.isDirty();
            var inf=ob.getDirtyFields();

            result=result && "one"===inf[0].__getFieldName();
            result=result && 1===inf.length;
            ob.destruct();
            return result;
        });
    d1 = defInstance.getDefinition2();
    runTest(
        "BaseTypedObjectModel: Comprobacion simple de campo con error",
        "Se crea un BTO y se asigna un campo a un valor no valido.Se comprueba la excepcion, y que el campo se ha marcado como con error.Se le asigna después un valor correcto, y se comprueba que la condición de error se ha limpiado.",
        d1
        ,
        function (def) {
            var obj= new Siviglia.model.BaseTypedObject(def);
            obj.one="one";
            var thrown=false;
            var result=true;
            try{
                obj.one="w";
            }catch(e)
            {
                thrown=true;
                result=result && (e.type=="StringException" && e.code==Siviglia.types.StringException.ERR_TOO_SHORT);
            }
            result=result && true==thrown;
            result=result && true==obj.__isErrored();
            var errored=obj.getErroredFields();
            result=result && 1==errored.length;
            result=result && true==obj["*one"].__isErrored();
            result=result && true==obj["*one"].__getError()!==null;
            result=result && "/one"==errored[0].__getFieldPath();
            // Le damos ahora un valor valido. Deberia borrarse el error.
            obj.one="ssss";
            result=result && false==obj["*one"].__isErrored();
            result=result && null==obj["*one"].__getError();
            result=result && false==obj.__isErrored();
            obj.destruct();
            return result;
    });
    d1 = defInstance.getDefinition2();
    runTest(
        "BaseTypedObjectModel: Comprobacion de errores generados por cambios de estado",
        "Se comprueba que los errores generados por cambios de estado, se asignan correctamente a los campos que los generan.",
        d1
        ,
        function (def) {
            var obj= new Siviglia.model.BaseTypedObject(def);

            var result="status"==obj.getStateField();
            result=result && 'None'==obj["*status"].getLabel();
            obj.three="thr";
            var thrown=false;
            obj.setValue({"status": "None", "three": "qq", "one" : "lala"});
            try {
                obj.two="hola";
            }catch(e) {
                thrown=true;
                result=result && (e.type=="BaseTypedException" && e.code==Siviglia.model.BaseTypedException.ERR_NOT_EDITABLE_IN_STATE);
                result=result && true==obj.__isErrored();
                erroredFields=obj.getErroredFields();
                result=result && 1== erroredFields.length;
                thrown=true;
            }
            result=result && true==thrown;
            // Ese ultimo cambio de estado no deberia lanzar excepciones
            obj.status="Other";
            obj.destruct();
            return result;
    });
    d1 = defInstance.getDefinition2();
    runTest(
        "BaseTypedObjectModel: Comprobacion de errores generados por cambios de estado (2)",
        "Se comprueba que los errores generados por cambios de estado, se asignan correctamente a los campos que los generan.La excepcion lanzada, y la que se almacena en el objeto, es la misma (de hecho, es el mismo objeto)",
        d1
        ,
        function (def) {

            var obj= new Siviglia.model.BaseTypedObject(def);
            obj.status="None";
            var thrown=false;
            var result=true;

            try{
                obj.status="Another";
            }
            catch(e) {
                thrown=true;
                var errored=obj.getErroredFields();
                result=result && 2==errored.length;
                result=result && "/three"==errored[0].__getFieldPath();
                var exception=errored[0].__getError();
                result=result && exception.type=='BaseTypedException';
                result=result && exception.code==Siviglia.model.BaseTypedException.ERR_REQUIRED_FIELD;

                exception=errored[1].__getError();
                result=result && exception.type=='BaseTypedException';
                result=result && exception.code==Siviglia.model.BaseTypedException.ERR_INVALID_STATE_TRANSITION;
                result=result && exception.path==="/status";
                thrown=true;
            }


            // Ahora, establecemos el campo que nos falta, y vemos si al establecer ese campo, el cambio de estado
            // se completa, y el container pasa a tener cero errores.
            obj.three="lala";
            var nErrors=obj.getErroredFields();

            result=result && true===thrown && nErrors.length===0 && obj["*status"].__isErrored()===false;
            obj.destruct();
            return result;
    });
    d1 = defInstance.getDefinition2();
    runTest(
        "BaseTypedObjectModel: Comprobacion de cambio de estado ok",
        "Se comprueba que la definicion usada en los ejemplos anteriores cambia de estado de forma correcta, cuando los campos que requiere estan presentes",
        d1
        ,
        function (def) {
            var obj= new Siviglia.model.BaseTypedObject(def);
        obj.three="Test";
        obj.status="Another";
        var result= "Another"==obj["*status"].getLabel();
        obj.destruct();
        return result;
    });
    d1 = defInstance.getDefinition2();
    runTest(
        "BaseTypedObjectModel: Otra comprobacion de cambio de estado incorrecto",
        "Utilizando la misma definicion, se intenta pasar de un estado (Another) a otro (Other), que solo permite transicionar a él desde el estado None,lo que provoca la excepcion",
        d1
        ,
        function (def) {
            var obj= new Siviglia.model.BaseTypedObject(def);
            obj.three="Hola";
            obj.status="Another";
            obj.cleanDirtyFields();
            var thrown=false;
            var result=true;
            try{
                obj.status="Other";
            }catch(e) {
                thrown=true;
                result = e.type == 'BaseTypedException';
                result = result && e.code == Siviglia.model.BaseTypedException.ERR_CANT_CHANGE_STATE_TO;
            }
            obj.destruct();
            return result && thrown;
    });
    /**
     * Test 10: Error al cargar datos, ya que se intenta ir a un estado
     * no posible desde el estado actual:
     */
    d1 = defInstance.getDefinition2();
    runTest(
        "BaseTypedObjectModel: Error al intentar una transicion de estado no permitida",
        "Se intenta pasar de un estado a otro, cuando esa transicion no esta permitida.",
        d1
        ,
        function (def) {
            var obj= new Siviglia.model.BaseTypedObject(def);
            obj.three="THR";
            obj.status="Another";
            obj.save();
            var result=true;
            var thrown=false;
            try {
                obj.status = "Other";
            }catch(e)
            {
                thrown=true;

                var errored=obj.getErroredFields();
                result=result && errored.length===1;

                var erroredField=errored[0];
                result=result && erroredField.__getFieldName()==="status";
            }
            obj.destruct();
            return result && thrown;
    });
    d1 = defInstance.getDefinition2();
    runTest(
        "BaseTypedObjectModel: Error al cambiar a estado no definido",
        "Se intenta pasar a un estado no definido, lanzandose un error de UNKNOWN_STATE",
        d1
        ,
        function (def) {
            var obj= new Siviglia.model.BaseTypedObject(def);
            var result=true;
            var thrown=false;
            try{
                obj.status="NotExistent";
            }catch(e)
            {
                thrown=true;
                result = e.type == 'BaseTypedException';
                result = result && e.code == Siviglia.model.BaseTypedException.ERR_UNKNOWN_STATE;
            }
            obj.destruct();
            return result && thrown;
    });

    var classDeclaration =
        "  \"SimpleTypedObject\": {\n" +
        "                    inherits:'Siviglia.model.BaseTypedObject',\n"+
        "                    construct:function()\n" +
        "                    {\n" +
        "                        this.__one=null;\n" +
        "                        this.__two=null;\n" +
        "                        this.__three=null;\n" +
        "                        this.__four=null;\n" +
        "                        this.__five=null;\n" +
        "                        this.__testedOk=false;\n" +
        "                        this.__testedNok=false;\n" +
        "                        this.__enteringCalled=false;\n" +
        "                    },\n" +
        "                    methods:{\n" +
        "                        check_five:function(value){if(value==\"five\")return true;return false;},\n" +
        "                        process_five:function(value){return \"six\";},\n" +
        "                        callback_one:function(){this.__one=\"one\";},\n" +
        "                        callback_two:function(){this.__two=\"set\";},\n" +
        "                        callback_three:function(){this.__three=\"three\";},\n" +
        "                        callback_four:function(){this.__four=\"four\";},\n" +
        "                        test_ok:function(){this.__testedOk=true;return true;},\n" +
        "                        test_nok:function(){this.__testedNok=true;return false;},\n" +
        "                        get_seven:function(){return \"seven\";},\n" +
        "                        check_eight:function(value){return value.length>3;},\n" +
        "                        process_eight:function(value){return value+\"##\";},\n" +
        "                        enteringState:function(){this.__enteringCalled=true;return true;}\n" +
        "                    }\n" +
        "                }";
    var classContainer = createHTMLElement('div', 'result', )
    var classContainerTitle = createHTMLElement('div', 'resultOk', classContainer, 'Clase utilizada en los tests de estado, con los callbacks definidos para test y cambio de estado')
    var classShow = createHTMLElement('div', 'testCode', classContainer, "<pre>" + hljs.highlightAuto(classDeclaration).value + "</pre>")
    var classHTML=classContainer.outerHTML;

    var d1 = defInstance.getDefinition4();
    runTest('BaseTypedObjectModel: ' + classHTML + "Tests de llamada de callbacks",
        "Al cambiar el estado del objeto, se llaman diferentes callbacks:ON_ENTER,ON_LEAVE y TESTS.Los callbacks de TEST se llaman para verificar que el cambio de estado se permite.En la definicion usada en este ejemplo, hay un test que siempre devuelve falso, asociado al paso al estado Another. Es por eso que salta una excepcion al intentar ir a ese estado.",
        d1,
        function (def) {
            var obj= new Test.SimpleTypedObject(def);
            obj.status="Other";
            var result=true;
        // Se ha abandonado el estado None, por lo que se ha tenido que ejecutar
        // el LISTENER_TAG ONE, es decir, el callback_one, y la variable __one debe valer "one".
        // Tambien se ha entrado en el estado Other, desde el estado None,
        // por lo que se ha tenido que ejecutar el LISTENER_TAG "TWO"
            result=result && "one"==obj.__one;
            result=result && "set"==obj.__two;
            result=result && null==obj.__three;
            obj.cleanDirtyFields();
        // Se pasa de "Other" a "Another": Debe fallar porque el test_nok se
        // ejecuta, y devuelve false.Se comprueba la excepcion, y que se ha
        // ejecutado el test.
            obj.three="thr";
            var thrown=false;
            try {
                obj.status="Another";

            }catch(e)
            {
                thrown=true;
                result = e.type == 'BaseTypedException';
                result = result && e.code == Siviglia.model.BaseTypedException.ERR_CANT_CHANGE_STATE;
            }
            obj.destruct();
        return result && thrown;
    });
    d1 = defInstance.getDefinition4();
    runTest(
        "BaseTypedObjectModel: Segundo test de callbacks de estado",
        "Esta vez, se aplica otro callback de TEST, que en este caso retorna true, por lo que se acepta el cambio de estado.El callback de test, ademas, establece el valor de una variable. Se comprueba que esa variable ha cambiado, por lo que el callback se ha llamado.",
        d1
        ,
        function (def) {
            var obj = new Test.SimpleTypedObject(def);
            obj.status = "Other";
            obj.cleanDirtyFields();
            obj.status="None";
            var result=true;
            result=result && true==obj.__testedOk;
            obj.destruct();
            return result;

        });
    d1 = defInstance.getDefinition4();
    runTest(
        "BaseTypedObjectModel: Tercer test de callbacks de estado",
        "Esta vez, se ejecuta tanto un METHOD como un PROCESS, especificados en el ON_ENTER del estado Another",
        d1
        ,
        function (def) {
            var obj = new Test.SimpleTypedObject(def);

        obj.three="thr";
        obj.status="Last";
        var result=true;
        // Se ejecuta tanto el tag THREE como el proceso P_ONE
        result=result && "three"==obj.__three;
        result=result && "one"==obj.__one;
        result=result && "set"==obj.__two;
        //Ademas, al haber entrado al estado Last, tiene que haberse ejecutado
        // el TEST_OK, por lo que __testedOk debe ser true
        result=result && true==obj.__testedOk;
        obj.destruct();
        return result;
    });

    d1 = defInstance.getDefinition4();
    runTest(
        "BaseTypedObjectModel: Comprobacion de que no es posible salir de un estado final",
        "",
        d1
        ,
        function (def) {
            var obj = new Test.SimpleTypedObject(def);
            obj.three = "thr";
            obj.status = "Last";
            obj.cleanDirtyFields();
            var thrown=false;
            var result=true;
            try{
                obj.status="None";
            }catch(e)
            {
                thrown=true;
                result = e.type == 'BaseTypedException';
                result = result && e.code == Siviglia.model.BaseTypedException.ERR_CANT_CHANGE_FINAL_STATE;
            }
            obj.destruct();
            return result && thrown;

        });
    d1 = defInstance.getDefinition5();
    runTest(
        "BaseTypedObjectModel: Comprobacion de callbacks especificados con *",
        "La especificacion de callbacks asociados a ENTER,LEAVE o TEST, puede ser diferente segun el estado del que se sale o al que se llega. Esos estados se pueden especificar con el nombre del estado, o con el caracter *, para cualquier otro estado que no se haya especificado.",
        d1
        ,
        function (def) {
            var obj = new Test.SimpleTypedObject(def);
            obj.three="thr";
            obj.status="Last";
            var result=true;
            // Se ha tenido que ejecutar el callback "TWO" via el estado "*"
            result=result && "set"==obj.__two;
            obj.destruct();
            return result;
        });
    d1 = defInstance.getDefinition5();
    runTest(
        "BaseTypedObjectModel: Comprobacion de callbacks independientes",
        "La especificacion de callbacks asociados a ENTER,LEAVE o TEST, puede ser independiente del estado al que se llega o del que se sale",
        d1
        ,
        function (def) {
            var obj = new Test.SimpleTypedObject(def);
            obj.three="thr";
            var result=true;
            result=result && null==obj.__three;
            obj.status="Other";
            // Se ha tenido que ejecutar el callback "TWO" via el estado "*"
            result=result && "three"==obj.__three;
            obj.destruct();
            return result;
        });

    d1 = defInstance.getDefinition6();
    runTest(
        "BaseTypedObjectModel: Comprobacion de path simple",
        "Simple obtencion del valor de un campo, a traves del path",
        d1
        ,
        function (def) {
            var obj = new Test.SimpleTypedObject(def);
            obj.one="str_one";
            var result=true;
            val=obj.getPath("/one");
            result=result && "str_one"==val;
            obj.destruct();
            return result;
        });
    d1 = defInstance.getDefinition6();
    runTest(
        "BaseTypedObjectModel: Comprobacion de paths complejos",
        "Obtencion de valores a partir de paths, atravesando arrays y diccionarios",
        d1
        ,
        function (def) {
            var obj = new Test.SimpleTypedObject(def);
            obj.one = "str_one";
            obj.arr = ["c1", "c2"];
            obj.dict = {}
            obj.dict.c1 = "f1";
            obj.dict.c2 = ["first", "second"];
            var result=true;
            val = obj.getPath("/arr/0");
            result = result && "c1" == val;
            val2 = obj.getPath("/dict/c1");
            result = result && "f1" == val2;
            val3 = obj.getPath("/dict/c2/1");
            result = result && "second" == val3;
            obj.destruct();
            return result;
        });
    d1 = defInstance.getDefinition6();
    runTest(
        "BaseTypedObjectModel: Comprobacion de paths complejos 2",
        "Obtencion de valores a partir de un path que contiene una referencia a otro campo",
        d1
        ,
        function (def) {
            var obj = new Test.SimpleTypedObject(def);
            obj.one="arr";
            obj.arr=["c1","c2"];
            var val=obj.getPath("/{%/one%}/0");
            var result=true;
            result=result && "c1"==val;
            obj.destruct();
            return result;
        });
    runTest(
        "BaseTypedObjectModel: Comprobacion de paths complejos 3",
        "Obtencion de valores a partir de un path que contiene una referencia a otro campo",
        {
            "FIELDS":{
                "one":{"TYPE":"String"},
                "two":{"TYPE":"String"},
                "state":{"TYPE":"State","VALUES":["E1","E2","E3"],"DEFAULT":"E1"},
                "inner":{
                    "TYPE":"Container",
                    "REQUIRED":true,
                        "FIELDS":{
                            "one":{"TYPE":"String"},
                            "two":{"TYPE":"String"},
                            "three":{"TYPE":"String"},
                            "state":{"TYPE":"State","VALUES":["E1","E2","E3"],"DEFAULT":"E1"}
                        },
                        'STATES' : {
                            'STATES' : {
                                'E1' : {
                                    'FIELDS' : {
                                        'EDITABLE' : ['one','two','inner']
                                    }
                                },
                                'E2' : {
                                    'ALLOW_FROM':["E1"],
                                    'FIELDS' : {'EDITABLE' : ['two','three']}
                                },
                                'E3' : {
                                    'ALLOW_FROM':["E2"],
                                    'FINAL':true,
                                    'FIELDS' : {'REQUIRED' : ['three']}}
                            },
                            'FIELD' : 'state'
                        }
                    }
                },
                'STATES' : {
                    'STATES' : {
                        'E1' : {
                            'FIELDS' : {'EDITABLE' : ['one','two','inner']}
                        },
                        'E2' : {
                            'ALLOW_FROM':["E1"],
                            'FIELDS' : {'EDITABLE' : ['two','three']}
                        },
                        'E3' : {
                            'ALLOW_FROM':["E2"],
                            'FINAL':true,
                            'FIELDS' : {'REQUIRED' : ['three']}}
                    },
                    'FIELD' : 'state'
                }
            }
        ,
        function (def) {
            var t=new Siviglia.model.BaseTypedObject(def);
            // Se intenta asignar un valor no valido del container interno:
            var thrown=false;
            var result=true;
            try {
                t.setValue({"one":"aa","state":"E1","inner":{"three":"zzz","state":"E1"}});
            }catch(e)
            {
                thrown=true;
                var isErrored=t.__isErrored();
                var isErrored2=t["*inner"].__isErrored();
                var isErrored3=t.inner["*three"].__isErrored();
                result=result && isErrored && isErrored2 && isErrored3;
                var e1=t.getErroredFields();
                var path=e1[0].__getFieldPath();
                var e2=t["*inner"].getErroredFields();
                var path2=e2[0].__getFieldPath();
                result=result && "/inner"===path;
                result=result && "/inner/three"===path2;
            }
            result=result && thrown;
            // Arreglamos el campo inner:
            t.inner={"one":"qq","state":"E1"};
            var isErrored=t.__isErrored();
            var isErrored2=t["*inner"].__isErrored();

            var isErrored3=t.inner["*three"].__isErrored();

            result=result && false==( isErrored || isErrored2 || isErrored3);
            // Se pasa el inner al estado E2, y luego a E3, donde deberia dar un error, ya que three es requerido
            t.inner.state="E2";
            thrown=false;
            try {
                t.inner.state="E3";
            }catch(e)
            {
                thrown=true;
                result = e.type == 'BaseTypedException';
                result = result && e.code == Siviglia.model.BaseTypedException.ERR_INVALID_STATE_TRANSITION;
                isErrored=t.__isErrored();
                isErrored2=t["*inner"].__isErrored();
                var e1=t.getErroredFields();
                var path=e1[0].__getFieldPath();
                var e2=t["*inner"].getErroredFields();
                path2=e2[0].__getFieldPath();
                result=result && "/inner"==path;
                result=result && "/inner/three"==path2;
            }
            result=result && thrown;
            t.destruct();
            return result;
        });

    runTest("Container: Valor vacio en valor por defecto.",
        "Comprobacion de que si los valores de un container, son siempre los valores por defecto, el valor del container es nulo",
        {
            "FIELDS": {
                "q1": {
                    "TYPE":"Container",
                    "FIELDS": {
                        "f1": {
                            "TYPE": "String",
                            "DEFAULT": "Value3"
                        },
                        "f2": {
                            "TYPE": "String",
                            "DEFAULT": "Value3"
                        }
                    }
                }
            }
        },
        function (def) {
            var t1 = new Siviglia.model.BaseTypedObject(def);
            var v=t1.getPlainValue();
            var status=(v===null);
            t1.q1={f1:"qq"};
            v=t1.getPlainValue();
            status = status && v.q1.f1==="qq" && v.q1.f2==="Value3";
            t1.destruct();

            return status;
        }, true);

    runTest("Source: Comprobacion de source en Arrays, al asignar arrays completos",
        "Se comprueba que, al asignar un array, las funciones de comprobacion de fuentes comprueban todos los elementos del array",
        {
            "FIELDS": {
                "a1": {
                    "TYPE": "Array",
                    "ELEMENTS": {
                        "TYPE": "String"
                    },
                    "SOURCE": {
                        "TYPE":"Path",
                        "PATH":"#../a2"
                    }
                },
                "a2":{
                    "TYPE": "Array",
                    "ELEMENTS":{
                        "TYPE":"Container",
                        "FIELDS":{
                            "LABEL":{"TYPE":"String"},
                            "VALUE":{"TYPE":"String"}
                        }
                    }
                }
            }
        },
        function (def) {
            var t1 = new Siviglia.model.BaseTypedObject(def);
            t1.a2=[{"LABEL":"uno","VALUE":"uno"},
                {"LABEL":"dos","VALUE":"dos"},
                {"LABEL":"tres","VALUE":"tres"},
                ];
            var thrown=false;
            try{
                t1.a1=["cuatro"];
            }catch(e)
            {
                thrown=true;
            }
            var status=thrown===true;
            t1.a2.push(
                {"LABEL":"cuatro","VALUE":"cuatro"}
            );
            status=status && t1["*a1"].__isErrored()===false;
            t1.destruct();
            return status;
        }, true);

    runTest("BaseTypedObject: Revocacion de proxy",
        "Una vez que se borra un valor de un tipo, las referencias a él provocan un error al accederse a ellas."+
        "La forma correcta de mantener el valor, es a traves de getPlainValue()",
        {
            "FIELDS": {
                "a1": {
                    "TYPE": "Array",
                    "ELEMENTS": {
                        "TYPE": "String"
                    }
                },
                "a2":{
                    "TYPE": "Array",
                    "ELEMENTS":{
                        "ELEMENTS": {
                            "TYPE": "String"
                        }
                    }
                }
            }
        },
        function (def) {
            var t1 = new Siviglia.model.BaseTypedObject(def);
            t1.a1=["a","b","c"];
            var s=t1.a1;
            var s1=t1["*a1"].getPlainValue();
            t1.a1=null;

            // Acceder a traves de s, da error
            var thrown=false;
            try {
                var q=t1.a1.length;
            }catch(e)
            {
                thrown=true;
            }
            // A traves de s1, si es posible acceder a la longitud
            var status=thrown && s1.length===3;

            t1.destruct();
            return status;
        }, true);


    runTest(
      'Array: Array con campos container',
      'Array cuyos elementos son de tipo container',
      {

        "FIELDS": {
          "f3": {
            "TYPE": "Array",
            "ELEMENTS": {
              "TYPE": "TypeSwitcher",
              "TYPE_FIELD": "TYPE",
              "ALLOWED_TYPES": {
                "T1": {
                  "TYPE": "Container",
                  "FIELDS": {
                    "TYPE": {
                      "TYPE": "String",
                      "FIXED": "T1"
                    },
                    "CAMPO": {
                      "TYPE": "String"
                    }
                  }
                },
                "T2": {
                  "TYPE": "Container",
                  "FIELDS": {
                    "TYPE": {
                      "TYPE": "String",
                      "FIXED": "T2"
                    },
                    "CAMPO2": {
                      "TYPE": "String"
                    }
                  }
                },
                "T3": {
                  "TYPE": "Container",
                  "FIELDS": {
                    "TYPE": {
                      "TYPE": "String",
                      "FIXED": "T3"
                    },
                    "CAMPO3": {
                      "TYPE": "String"
                    }
                  }
                }
              }
            }
          }
        }

      },
      function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
          def
        );
        var f=t1["*f3"];
        var nErrors = 0;
        var nChanges = 0;

        f.addListener("CHANGE", null, function () {
          nChanges++
        });
        var a1={"TYPE":"T1","CAMPO":"abcde"};
        var a2={"TYPE":"T2", CAMPO2:'qwer'};
        var a3={"TYPE":"T3","CAMPO3":"jklm"};
        f.setValue([a1,a2,a3]);
        f[0].CAMPO='campocambiado'

        f.splice(0,1);

        var status=f[0].CAMPO2==="qwer" && f[1].CAMPO3==="jklm" && f.length===2;

        // El splice ha movido el elemento que antes estaba en 2, a la posicion 1. Para que esto funcione, ha
        // habido que crear un nuevo typeswitcher en 1, con el valor del typeswitcher que habia en 2.

        // Lo importante, es que ese valor siga apuntando al mismo objeto, de forma que sigue siendo el mismo
        // valor referenciado por a3. Asi que si cambiamos a3, lo que hay en f[1] tiene que cambiar tambien.
        // NOTA: LO ANTERIOR NO ES POSIBLE: EL TYPESWITCHER QUE HABIA EN 2, EVENTIZO EL OBJETO a3 PARA QUE APUNTARA A ÉL.
        // SI LUEGO ESE OBJETO PASA A SER EL VALOR DEL TYPESWITCHER QUE SE CREA EN 1, SOLO HABRIA 2 POSIBILIDADES:
        // 1) RE-EVENTIZAR a3 PARA QUE AHORA APUNTE AL TYPESWITCHER NUEVO. ESTO NO ES POSIBLE, PORQUE NADIE GARANTIZA
        // QUE EL TYPESWITCHER QUE HAY EN 2 (Y QUE LO EVENTIZÓ INICIALMENTE), VAYA A DESAPARECER: LO SIGUE USANDO. SERIA
        // UN VALOR COMPARTIDO
        // 2) NO RE-EVENTIZAR : a3 SEGUIRIA APUNTANDO A TYPESWITCHER 2, QUE VA A SER DESTRUIDO.
        // ASI QUE NO QUEDA MAS REMEDIO QUE HACER UNA COPIA!


        // a3.CAMPO3="JORGITO";
        a3=f[1];
        a3.CAMPO3="JORGITO";



        status= status && f[1].CAMPO3==="JORGITO";

        t1.destruct();

        return status && countListeners() == 0;
      },
      true
    )


</script>
<script>
  // if (DEVELOP_MODE <= 98) {
  //   DEVELOP_MODE++
  //   setTimeout(function () {
  //     window.open("http://0.0.0.0:9000/packages/Siviglia/tests/VTest.html?test=" + DEVELOP_MODE, "_self")
  //   }, 1000)
  // }
  checkTests();

</script>
</body>
</html>
