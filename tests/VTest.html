<html>
<head>
    <meta charset="UTF-8">
    <script src="/node_modules/jquery/dist/jquery.js"></script>
    <script src="../Siviglia.js"></script>

    <script src="../SivigliaStore.js"></script>
    <script src="../SivigliaTypes.js"></script>
    <script src="../Model.js"></script>
    <script src="./jsonView/jquery.json-view.min.js"></script>
    <link rel="stylesheet"
          href="./jsonView/jquery.json-view.min.css">
    <link rel="stylesheet"
          href="highlight/styles/monokai.css">
    <script src="highlight/highlight.pack.js"></script>
    <style type="text/css">
        .testDiv {}
        .testTitle {}
        .testCont {}
        .testDoc {
            background-color: white;
            color: black;
            border: 2px solid gray;
            padding: 4px;
        }
        .testDef {
            background-color:white;color:black;
            height:150px;
            float:left;
            width:300px;
        }
        .testCode {
            background-color:black;
            height:150px;
            overflow-y:scroll;
        }
    </style>

    <script>
        var Siviglia = Siviglia || {};
        Siviglia.config = {
            baseUrl: 'http://editor.adtopy.com/',
            staticsUrl: 'http://statics.adtopy.com/',
            metadataUrl:'http://metadata.adtopy.com/',
            jsFramework: 'jquery',
            locale: 'es-ES',
            mapper: 'Siviglia',
            datasourcePrefix: 'datasource/'
            //jsFramework:'dojo'
        };
        Siviglia.Model.initialize(Siviglia.config);
    </script>

    <style type="text/css">
        .resultError {
            background-color: #cc3636;

        }

        .result {
            margin: 2px;
            padding: 3px;
            color: honeydew;
        }

        .resultOk {
            background-color: green;

        }
    </style>
</head>
<body>
<div id="result"></div>

<script>
    hljs.initHighlightingOnLoad();
    var DEVELOP_MODE=33;

    var def1={
        "TYPE":"Container",
        "FIELDS": {
            "one": {"TYPE": "String", "MINLENGTH": 2, "MAXLENGTH": 10},
            "two": {"TYPE": "String", "DEFAULT": "Hola"}
        }
    };
    
    var def2={
        "TYPE":"Container",
        "FIELDS":{
        "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":10},
        "two":{"TYPE":"String","REQUIRED":true},
        "three":{"TYPE":"Integer"},
        "four":{"TYPE":"Integer","KEEP_KEY_ON_EMPTY":true}
    }
    };

    var def3={
        "TYPE":"Container",
        "FIELDS":{
        "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":10},
        "two":{"TYPE":"String"}
    }
    };
    var def4={
        "TYPE":"Container",
        "FIELDS":{
        "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":10,"KEEP_KEY_ON_EMPTY":true},
        "two":{"TYPE":"String"}
    }
    };
    var def5={
        "TYPE":"Container",
        "FIELDS":{
        "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":10,"KEEP_KEY_ON_EMPTY":true},
        "two":{"TYPE":"String"}
    },
        "DEFAULT":{
        "one":"1111",
        "two":"2222"
    }
    };

    var def6={
        "TYPE":"Container",
        "FIELDS":{
        "one":{
        "TYPE":"Array",
        "ELEMENTS":{
        "TYPE":"Container",
        "FIELDS":{
        "f1":{
        "TYPE":"Dictionary",
        "VALUETYPE":{
        "TYPE":"Container",
        "FIELDS":{
        "q1":{"TYPE":"String"},
        "q2":{"TYPE":"Integer"}
    }

    }
    },
        "f2":{
        "TYPE":"TypeSwitcher",
        "TYPE_FIELD":"Type",
        "CONTENT_FIELD":"Value",
        "ALLOWED_TYPES":{
        "String":{"TYPE":"String"},
        "Integer":{"TYPE":"Integer"}
    }
    }
    }
    }
    },
        "two":{"TYPE":"String"}
    }
    };

    var def = {
        "FIELDS": {
            "f1": {
                "TYPE": "Array",
                "VALUETYPE": {

                    "TYPE": "String"
                }
            },
            "f2": {
                "TYPE": "TypeSwitcher",
                "TYPE_FIELD": "TYPE",
                "ALLOWED_TYPES": {
                    "TIPO1": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "f3": {"TYPE": "String", "MINLENGTH": 2},
                            "f4": {"TYPE": "Integer"}
                        }
                    },
                    "TIPO2": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "f1": {"TYPE": "String", "MINLENGTH": 2},
                            "f2": {"TYPE": "Integer"}
                        }
                    }
                }
            },
            "f3": {
                "TYPE": "TypeSwitcher",
                "TYPE_FIELD": "TYPE",
                "IMPLICIT_TYPE": "TIPO3",
                "ALLOWED_TYPES": {
                    "TIPO3": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "f3": {"TYPE": "String", "MINLENGTH": 2},
                            "f4": {"TYPE": "Integer"}
                        }
                    },
                    "TIPO4": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "f1": {"TYPE": "String", "MINLENGTH": 2},
                            "f2": {"TYPE": "Integer"}
                        }
                    }
                }
            },
            "f4": {
                "TYPE": "TypeSwitcher",
                "TYPE_FIELD": "TYPE",
                "CONTENT_FIELD": "value",
                "IMPLICIT_TYPE": "TIPO6",
                "ALLOWED_TYPES": {
                    "TIPO6": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "f3": {"TYPE": "String", "MINLENGTH": 2},
                            "f4": {"TYPE": "Integer"}
                        }
                    },
                    "TIPO7": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "f1": {"TYPE": "String", "MINLENGTH": 2},
                            "f2": {"TYPE": "Integer"}
                        }
                    }
                }
            },
            s1: {
                "TYPE": "String",
                "MINLENGTH": 3,
                "MAXLENGTH": 4
            },
            s2: {
                "TYPE": "String",
                "REGEXP": "/aa/"
            }
        }
    };
    var testNumber = 0;
    var runningTests=false;
    var cbStack=[];
    function countListeners() {
        var s = 0;
        for (var k in Siviglia.Dom.existingListeners)
            s++;
        return s;
    }

    function showResult(name,doc,def,callback,testNumber,expected,result,exception)
    {
        var className = "result resultError";
        var message = "ERROR";
        if(!exception)
        {
            if (JSON.stringify(expected) == JSON.stringify(result)) {
                className = "result resultOk";
                message = "OK!";
            }
        }
        else
            message="ERROR:"+exception;

        var nDiv = document.createElement("div");
        nDiv.className="testDiv "+className;
        var divTitle=document.createElement("div");
        nDiv.appendChild(divTitle);
        divTitle.innerHTML = "Test " + testNumber + " (" + name + ") : " + message+" <i style='font-size:10px'>[listeners:"+countListeners()+"]</i>";
        divTitle.className="testTitle";
        var divDoc=document.createElement("div")
        divDoc.innerHTML=doc;
        divDoc.className="testDoc";
        nDiv.appendChild(divDoc);
        var divCont=document.createElement("div");
        divCont.className="testCont";
        divCont.style.height="50px";
        nDiv.appendChild(divCont);
        var divDef=document.createElement("div");

        divDef.style.overflowY="scroll";
        divDef.className="testDef";
        $(divDef).jsonView(def);
        divCont.appendChild(divDef);
        var divCode=document.createElement("div");
        divCode.className="testCode";
        divCode.innerHTML="<pre>"+hljs.highlightAuto(callback.toString()).value+"</pre>";
        divCont.appendChild(divCode);
        divClear=document.createElement("div");
        divClear.style.clear="both";
        nDiv.appendChild(divClear);


        document.getElementById("result").appendChild(nDiv);
    }
    function checkTests(restart)
    {
        if(runningTests==true)
        {
            return;
        }
        if(restart!==false) {
            if (DEVELOP_MODE !== 0) {
                if (DEVELOP_MODE === -1)
                    cbStack = [cbStack.pop()];
                else
                    cbStack = [cbStack[DEVELOP_MODE]];
            }
        }
        while(cbStack.length>0)
        {
            var cItem=cbStack.shift();
            try {
                var rs = cItem.cb.apply(null,[cItem.def]);
                if(rs && rs.then)
                {
                    // Es una promesa.
                    runningTests=true;
                    rs.then(function(r){
                        showResult(cItem.name,cItem.doc,cItem.def,cItem.cb,cItem.number,cItem.expectedResult,r,null);
                        runningTests=false;
                        checkTests(false);
                    })
                    return;
                }
                else
                    showResult(cItem.name,cItem.doc,cItem.def,cItem.cb,cItem.number,cItem.expectedResult,rs,null);

            } catch (e) {
                console.dir(e);
                showResult(cItem.name,cItem.doc,cItem.def,cItem.cb,cItem.number,cItem.expectedResult,rs,e);
            }

        }
    }
    function runTest(name, doc, def,cb, expectedResult) {
        testNumber++;
        if(typeof expectedResult=="undefined")
            expectedResult=true;
        cbStack.push({name:name,doc:doc,def:def,cb:cb,expectedResult:expectedResult,number:testNumber});

    }
    runTest("Simple Container","Prueba sencilla para comprobar que las librerias se inicializan correctamente",
       def1,
        function(def) {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            cnt.setValue({"one":"tres","two":"lalas"});
            var result=("tres"===cnt.one);
            return result && "lalas"===cnt.two;
        });
    runTest("Container: Prueba de campo requerido", "El campo two es requerido, lo cual provoca error.Hay que fijarse en que esta comprobacion se efectua al llamarse a save(), no antes, ya que no podemos saber a priori si esos campos se van a establecer después.Hay que tener en cuenta que la validacion de formularios, y cualquier intento de enviar un BTO al servidor, tiene primero que llamar a save() del objeto.",
        def2,
        function(def) {
            var cnt = Siviglia.types.TypeFactory.getType({"fieldName":"a","fieldPath":"/"},def,null,null);
            var thrown=false;
            var result=true;
            try {
                cnt.setValue({one:"tres"});
                cnt.save();
            }catch(e)
            {
                result=result && e.type==="BaseTypeException" && e.code===Siviglia.types.BaseTypeException.ERR_REQUIRED;
                // Tiene que estar errored.
                thrown=true;
            }
            return result && thrown;
        });
    runTest("Container: Prueba de campo erroneo","Se asigna un campo que no valida (cadena demasiado corta)",
    def1,
    function(def){
        var thrown=false;
        var result=true;
        var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
        try {
            cnt.setValue({"one":"a","two":"lalas"});
        }catch(e)
        {
            result=(result && e.type=="StringException" && e.code==Siviglia.types.StringException.ERR_TOO_SHORT);
            thrown=true;
        }
        return result && thrown;
    });
    runTest("Container: Prueba de campo vacio","Se asigna un valor nulo, y se testea la funcion HasOwnValue",
    def1,
        function(def){
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            cnt.setValue(null);
            return cnt.__hasOwnValue()==false;
        }
    )
    runTest("Container: Valor inicial nulo","Se comprueba que un container al que no se le ha asignado un valor, tiene un valor nulo",
    def1,
        function(def)
        {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            var n=cnt.getValue();
            return n===null;
        }
    )
    runTest("Container: Valor nulo de campos","Se comprueba que campos no asignados tienen un valor nulo",
        def2,
        function(def)
        {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            cnt.setValue({"one":"tres","two":"lalas"});
            var tmp=cnt.getValue();
            return tmp.three===null && tmp.four===null;
        });
    runTest("Container: Valor por defecto de campos","Se comprueba que se aplica el valor por defecto cuando el campo se establece a nulo",
    def1,
        function(def)
        {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            cnt.setValue({"one":null,two:null});
            return cnt.two==="Hola";
        }
    )
    runTest("Container: Valor nulo cuando todos los campos son nulos","Se comprueba que, si los campos de un container son nulos, y no tienen KEEP_KEY_ON_EMPTY, el valor del container es nulo,al convertirlo a un valor plano.",
        def3,
        function(def)
        {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            cnt.setValue({"one":null,two:null});
            return null===cnt.getPlainValue();
        }
    )
    runTest("Container: Valor no nulo cuando todos los campos son nulos, preservando keys","Se comprueba que, si los campos de un container son nulos, pero tienen PRESERVE_KEYS_ON_NULL, el valor del container no es nulo, al convertirlo en un valor plano.",
        def4,
        function(def)
        {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            cnt.setValue({"one":null,two:null});
            var plain=cnt.getPlainValue();
            return null===plain.one;
        }
    )
    runTest("Container: Obtencion de path","Prueba de obtencion de campo a traves de un path",
        def6,
        function(def)
        {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            var v={
                "one":[
                    {
                        "f1": {
                            "k1-1": {"q1": "1", "q2": 2},
                            "k1-2": {"q1": "3", "q2": 4},
                            "k1-3": {"q1": "5", "q2": 6}
                        },
                        "f2": {
                            "Type": "String", "Value": "hola"
                        }
                    },

                    {
                        "f1":{
                            "k2-1":{"q1":"7","q2":8},
                            "k2-2":{"q1":"9","q2":10},
                        },
                        "f2":{
                            "Type":"String","Value":"hola"
                        }
                    }
                ],
                "two":"Lala"
            };
            cnt.setValue(v);
            var result= "Lala" === cnt.getPath("#two");
            cnt.destruct();
            return result;
        }
    )

    runTest("Container: Obtencion de path 2","Obtencion de un path mas profundo.Se comprueba que existen las claves de un container que existe dentro de varios campos.",
        def6,
        function(def)
        {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            cnt.setValue(
                {
                    "one":[
                        {
                            "f1": {
                                "k1-1": {"q1": "1", "q2": 2},
                                "k1-2": {"q1": "3", "q2": 4},
                                "k1-3": {"q1": "5", "q2": 6}
                            },
                            "f2": {
                                "Type": "String", "Value": "hola"
                            }
                        },

                        {
                            "f1":{
                                "k2-1":{"q1":"7","q2":8},
                                "k2-2":{"q1":"9","q2":10},
                            },
                            "f2":{
                                "Type":"String","Value":"hola"
                            }
                        }
                    ],
                    "two":"Lala"
                }
            );
            var val= cnt.getPath("#one/0/f1");
            cnt.destruct();
            var n=countListeners();
            return typeof val["k1-1"]!=="undefined" && typeof val["k1-2"]!=="undefined" && typeof val["k1-3"]!=="undefined" && countListeners()==0;
        }
    )
    runTest("Container: Obtencion de path 3","Obtencion de un path relativo: Primero se navega hasta un cierto elemento de la estructura, y luego se pide un path relativo",
        def6,
        function(def)
        {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            cnt.setValue(
                {
                    "one":[
                        {
                            "f1": {
                                "k1-1": {"q1": "1", "q2": 2},
                                "k1-2": {"q1": "3", "q2": 4},
                                "k1-3": {"q1": "5", "q2": 6}
                            },
                            "f2": {
                                "Type": "String", "Value": "hola"
                            }
                        },

                        {
                            "f1":{
                                "k2-1":{"q1":"7","q2":8},
                                "k2-2":{"q1":"9","q2":10},
                            },
                            "f2":{
                                "Type":"String","Value":"hola"
                            }
                        }
                    ],
                    "two":"Lala"
                }
            );
            var arr=cnt["*one"];
            var cnt2=arr[0];
            var dict=cnt2["*f1"];
            var cnt3=dict["*k1-1"];
            var field=cnt3["*q1"];
            var parent=field.__getParent();
            var v1=parent.getPath("#../k1-2/q1");
            var v2=parent.getPath("#../../f2/Value");
            console.log("ANTES:"+countListeners());
            cnt.destruct();
            var n=countListeners();
            return v1==="3" && v2==="hola" && countListeners()==0;
        }
    )

    runTest("Container: Chequeo de fuente","Establecimiento de un valor dependiente de una fuente. La fuente de un campo, es el valor de otro campo.Se prueba tanto un valor valido, como un valor no valido.",
        {
            "TYPE":"Container",
        "FIELDS":{
        "VALUES":{
        "TYPE":"Array",
        "ELEMENTS":{
        "TYPE":"Container",
        "FIELDS":{
        "VALUE":{"TYPE":"Integer"},
    "LABEL":{"TYPE":"String"}
    }
    }
    },
    "DEFAULT":{"TYPE":"String",
        "SOURCE":{
        "TYPE":"Path",
        "PATH":"#../VALUES",
        "LABEL":"LABEL",
        "VALUE":"LABEL"
    }
    }
    }
    },
        function(def)
        {
            var cnt = Siviglia.types.TypeFactory.getType("",def,null,null);
            var thrown=false;
            try {
                cnt.setValue(
                    {
                        "VALUES": [
                            {"VALUE": 1, "LABEL": "Pepito"},
                            {"VALUE": 2, "LABEL": "Juanito"}
                        ],
                        "DEFAULT": "Pepito"
                    }
                );
            }catch(e)
            {
                thrown=true;
            }
            var res= thrown===false;
            // Se intenta ahora ponerle un valor que NO existe en la fuente:
            var thrown=false;
            try{
                cnt.DEFAULT="Invalid"
            }catch(e)
            {
                thrown=true;

            }
            cnt.destruct();
            return res && thrown;
        }
    )
    runTest("Varios test de String", "Se prueba la validacion de Strings, y como añadir un listener de CHANGE a un campo.Este listener se dispara tambien cuando hay un error. Un contador cuenta el numero de CHANGES, y el numero de errores.",def,function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        var flag = 0;
        var nExcp = 0;
        var nErrors=0;
        t1.setValue({});
        t1["*s1"].addListener("ERROR", null, function () {
            nErrors++;

        })
        t1["*s1"].addListener("CHANGE", null, function () {
            flag++;

        })
        try {
            t1.s1 = "aa";
        } catch (e) {
            nExcp++;
        }
        try {
            t1.s1 = "zzzzzz";
        } catch (e) {
            nExcp++;
        }
        t1.s1 = "aaa";

        var n = countListeners();
        t1.destruct();
        var n1 = countListeners();
        return nExcp == 2 &&  flag===1 && nErrors==2 && n == 2 && n1 == 0;
    }, true);

    runTest("Comprobacion de nulos (1)","Se prueba que un valor no asignado devuelve nulo", def,function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        return t1.f2===null;
    }, true);
    runTest("Comprobacion de nulos (2)","Se prueba que un valor no asignado devuelve nulo", def,function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        return t1.f3===null;
    }, true);
    runTest("Comprobacion de nulos (3)","Se prueba que un valor no asignado devuelve nulo", def,function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        return t1.f4===null;
    }, true);
    runTest("Comprobacion TS 1", "Primera comprobacion de funcionamiento de un typeswitcher.Se ve que una vez establecido el tipo, los campos internos existen. Hay que tener en cuenta que hay que establecer al menos 1 campo, ya que, si no, el container tendria todos los campos a nulo, y, sin KEEP_KEY_ON_EMPTY, el container en si seria nulo.",
        def,
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.f2 = {TYPE: "TIPO1","f3":"aaa"};
        var s=t1.f2.f3;
        return typeof t1.f2.f3 !== "undefined" && typeof t1.f2["*f3"] !== "undefined" &&
               typeof t1.f2.f4 !== "undefined" && typeof t1.f2["*f4"] !== "undefined";
    }, true);
    runTest("Comprobacion TS 2", "Comprobacion del funcionamiento de IMPLICIT_TYPE: Si a un typeswitcher se le asigna un valor que no tiene el campo definido como campo de tipo, se utiliza el tipo indicado por IMPLICIT_TYPE",
        def,
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.f3 = {f3:"qqq"};
        return typeof t1.f3.f3 !== "undefined" && typeof t1.f3["*f3"] !== "undefined" && typeof t1.f3.f4 !== "undefined" && typeof t1.f3["*f4"] !== "undefined";
    }, true);
    runTest("Comprobacion TS 3", "Comprobacion de que en un typeswitcher, al cambiar de tipo (primero se crea un tipo implicito, y luego un TIPO4), los campos pertenecientes al primer tipo, ya no estan definidos.",
        def,
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.f3 = {f3:"aaa"};
        var result=typeof t1.f3.f3 !=="undefined";
        t1.f3 = {"TYPE": "TIPO4"}
        return result && typeof t1.f3.f3 == "undefined" && typeof t1.f3["*f3"] == "undefined" && typeof t1.f3.f4 == "undefined" && typeof t1.f3["*f4"] == "undefined";
    }, true);
    runTest("Comprobacion TS 4", "Comprobacion de acceso a un TypeSwitcher a traves de campos",def,
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.f4 = {value: {f3: "hola", f4: 25}};
        t1.f4.value.f3 = "pepito"
        return t1.f4.value.f3==="pepito";
    });
    runTest("Comprobacion Listener TS 1", "Comprobacion del funcionamiento de listeners sobre typeswitchers: se establece un listener para escuchar cuando cambia el tipo del typeswitcher",def,
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.f4 = {value: {f3: "hola", f4: 25}};
        var flag = 0;
        t1["*f4"].addListener("CHANGE", null, function () {
            flag = 1;
        })
        var n = countListeners();
        t1.f4.TYPE = "TIPO7";
        t1.destruct();
        var n2 = countListeners();
        return flag == 1 && n2 == 0 && n == 1;
    }, true);
    runTest("Comprobacion Listener TS 2", "Comprobacion del funcionamiento de listener de TypeSwitcher, al establecer el valor a nulo (hay que fijarse en que el listener se establece justo antes de establecer el valor a nulo.)",def,function () {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.f4 = {};
        t1.f4 = {value: {f3: "hola", f4: 25}};
        var flag = 0;
        t1["*f4"].addListener("CHANGE", null, function () {
            flag = 1;
        })
        var n = countListeners();
        t1.f4 = null;
        t1.destruct();
        var n2 = countListeners();
        return flag == 1 && n2 == 0 && n == 1;
    }, true);
    runTest("Comprobacion Listener TS 3", "Se establecen listeners sobre campos internos del typeswitcher.Se comprueba tambien que no quedan listeners colgados",def,
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.f4 = {value: {f3: "hola", f4: 25}};
        var flag = 0;
        var fire1=0,fire2=0,fire3=0,f3FiredFirst=false;
        t1["*f4"].addListener("CHANGE", null, function () {
            flag++;
            fire1=1;
        }, "Listener t4");
        t1["*f4"]["*value"].addListener("CHANGE", null, function () {
            flag++;
            fire2=1;
        }, "Listener value")
        t1.f4.value["*f3"].addListener("CHANGE", null, function () {
            flag++;
            fire3=1;
            if(fire1==0)
                f3FiredFirst=true;
        }, "Listener f3")
        var n = countListeners();
        t1.f4.value.f3 = "adios";
        t1.f4.TYPE = "TIPO7";
        t1.destruct();
        var n2 = countListeners();
        return flag == 2 && n2 == 0 && n == 3 && f3FiredFirst==true && fire3==1 && fire1==1;
    }, true);

    runTest("Comprobacion save() en BaseTypedObject",
        "Se comprueba el funcionamiento de Save en BaseTypedObject.Al llamar a save() se hacen las comprobaciones de los campos requeridos.Se intenta primero salvar un objeto incompleto, lo que tiene que hacer saltar una excepcion.Al establecer el valor que falta, la excepcion no debe saltar, por lo que se debe haber mantenido el valor de la variable e1",
        {
            "FIELDS": {
                "f1": {"TYPE": "String", "REQUIRED": true},
                "f2": {"TYPE": "String"}
            }
        },
        function (def) {
        var t2 = new Siviglia.model.BaseTypedObject(def);
        t2.f2 = "Lala";
        var e1 = 0;
        var errors=null;
        try {
            t2.save();

        } catch (e) {
            if(e.code && e.code==Siviglia.types.BaseTypeException.ERR_REQUIRED)
                    e1 = 1;

        }
        t2.f1 = "qqq";
        try {

            var errors=t2.save();
            if(errors && errors.length>0)
                e1=2;
        } catch (e) {
        }

        return e1===1;
    });
    runTest("Comprobacion de getPath en BaseTypedObject / TypeSwitcher",
        "Se comprueba el funcionamiento de getFullPath, que debe calcular el path completo de un campo.Aqui, el typeswitcher en si, no debe añadir nada al path.Ese campo debe ser transparente.",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "TypeSwitcher",
                    "TYPE_FIELD": "TYPE",
                    "CONTENT_FIELD": "value",
                    "ALLOWED_TYPES": {
                        "TIPO3": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "sf3": {"TYPE": "String", "MINLENGTH": 2},
                                "sf4": {"TYPE": "Integer"}
                            }
                        },
                        "TIPO4": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "sf1": {"TYPE": "String", "MINLENGTH": 2},
                                "sf2": {"TYPE": "Integer"}
                            }
                        }
                    }
                },
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.f3 = {TYPE: "TIPO3", value: {sf3: "lala"}};
        var path = t1.f3.value["*sf3"].__getFieldPath();
        return path == "/f3/value/sf3";
    }, true);

    runTest("Comprobacion de KEEP_ON_EMPTY en BaseTypedObject",
        "Se comprueba el funcionamiento de KEEP_ON_EMPTY.Un campo con el flag KEEP_ON_EMPTY se devuelve como NULL si no se ha asignado un valor.",
        {
            "FIELDS": {
                "f1": {"TYPE": "String", "KEEP_KEY_ON_EMPTY": true},
                "f2": {"TYPE": "String", "KEEP_KEY_ON_EMPTY": false}
            }
        },
        function (def) {
        var t2 = new Siviglia.model.BaseTypedObject(def);
        var r = t2.getPlainValue();
        return typeof r["f2"] == "undefined" && r.f1 === null;
    }, true);
    runTest("Comprobacion de DEFAULT en BaseTypedObject", "Se establece el valor por defecto de un BaseTypedObject completo",
        {
            "FIELDS": {
                "f2": {"TYPE": "String"},
                "TIPO2": {
                    "TYPE": "Container",
                    "FIELDS": {
                        "f1": {"TYPE": "String", "MINLENGTH": 2},
                        "f2": {"TYPE": "Integer"}
                    }
                }
            },
            "DEFAULT": {f2: "hola", TIPO2: {f1: "adios", f2: 50}}
        },
        function (def) {
        var t2 = new Siviglia.model.BaseTypedObject(def);
        return t2.f2 == "hola" && t2.TIPO2.f2 == 50;
    }, true);
    runTest("Comprobacion de save() en Container",
        "Se intenta guardar un objeto Container con un valor interno que es requerido.Cuando ese valor se establece, se deja de lanzar la excepcion",
        {
            "FIELDS": {
                "f2": {"TYPE": "String"},
                "TIPO2": {
                    "TYPE": "Container",
                    "FIELDS": {
                        "f1": {"TYPE": "String", "MINLENGTH": 2, "REQUIRED": true},
                        "TIPO7": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "f1": {"TYPE": "String", "MINLENGTH": 2},
                                "f2": {"TYPE": "Integer"}
                            }
                        }
                    }
                }
            },

        },
        function (def) {

        var t2 = new Siviglia.model.BaseTypedObject(def);
        var e = 0;
        var result=false;
        t2.TIPO2 = {"TIPO7": {f1: "Prueba", f2: 55}};
        try {
            t2.save();
        } catch (q) {
            result=(q.type=="BaseTypeException" && q.code==Siviglia.types.BaseTypeException.ERR_REQUIRED);
        }
        t2.TIPO2.f1 = "lala";
        t2.save();
        return result;

    }, true);


    runTest("Comprobacion de getPath() en Container",
        "Comprobacion de calculo correcto de paths de campos",
        {
            "FIELDS": {
                "f2": {"TYPE": "String"},
                "TIPO2": {
                    "TYPE": "Container",
                    "FIELDS": {
                        "f1": {"TYPE": "String", "MINLENGTH": 2},
                        "TIPO7": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "f1": {"TYPE": "String", "MINLENGTH": 2},
                                "f2": {"TYPE": "Integer"}
                            }
                        }
                    }
                }
            },

        },
        function (def) {

        var t2 = new Siviglia.model.BaseTypedObject(def);
        t2.TIPO2 = {"f1": "hola", "TIPO7": {f1: "Prueba", f2: 55}};
        var path = t2.TIPO2.TIPO7["*f2"].__getFieldPath();
        return path == "/TIPO2/TIPO7/f2";

    }, true);

    runTest("Comprobacion de SET_ON_EMPTY / KEEP_ON_EMPTY en Container",
        "Comprobacion de KEEP_KEY_ON_EMPTY y SET_ON_EMPTY",
        {
            "FIELDS": {
                "f1": {
                    "TYPE": "Container",
                    "SET_ON_EMPTY": true,
                    "FIELDS": {
                        "f1": {"TYPE": "String", "MINLENGTH": 2},
                        "f2": {"TYPE": "Integer"}
                    }
                },
                "TIPO2": {
                    "TYPE": "Container",
                    "SET_ON_EMPTY": false,
                    "FIELDS": {
                        "f1": {"TYPE": "String", "MINLENGTH": 2, "KEEP_KEY_ON_EMPTY": true},
                        "TIPO7": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "f1": {"TYPE": "String", "MINLENGTH": 2},
                                "f2": {"TYPE": "Integer"}
                            }
                        }
                    }
                }
            }

        },
        function (def) {

        var t2 = new Siviglia.model.BaseTypedObject(def);
        // NOTA: El path /TIPO2, tiene SET_ON_EMPTY a falso, pero a su vez tiene el campo f1 que tiene KEEP_ON_EMPTY a true.
        var r = t2.getPlainValue();
        // Lo que tiene que haber aqui es:
        // r.f1 : al tener SET_ON_EMPTY a true, pero sus campos son nulos, r.f1=={}
        // r.TIPO2 debe ser igual a {f1:null}
        var nKeys = 0;
        for (var k in r.f1)
            nKeys++;
        return nKeys == 0 && typeof r.TIPO2 !== "undefined" && r.TIPO2 != null && typeof r.TIPO2.TIPO7 == "undefined" && r.TIPO2.f1 == null;

    }, true)
    runTest("Comprobacion de getPath / DEFAULT en Dictionary",
        "Comprobaciones de valor por defecto y getPath en tipos Dictionary",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Dictionary",

                    "VALUETYPE": {

                        "TYPE": "Container",
                        "FIELDS": {
                            "sf3": {"TYPE": "String", "MINLENGTH": 2},
                            "sf4": {"TYPE": "Integer"}
                        }
                    },
                    "DEFAULT": {

                        "uno": {sf3: "Hola", sf4: 1},
                        "dos": {sf3: "Hola2", sf4: 2},
                        "tres": {sf3: "Hola3", sf4: 3},

                    }


                }
            }

        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);

        var path = t1.f3.uno["*sf3"].__getFieldPath();
        var status= path == "/f3/uno/sf3";
        t1.destruct();
        return status && countListeners()==0;
    }, true);
    runTest("Comprobacion de SET_ON_EMPTY en Dictionary",
        "Comprobacion del flag SET_ON_EMPTY en diccionarios",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Dictionary",
                    "SET_ON_EMPTY": true,
                    "VALUETYPE": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "sf3": {"TYPE": "String", "MINLENGTH": 2},

                        }
                    },
                },
                "f4": {
                    "TYPE": "Dictionary",
                    "VALUETYPE": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "sf3": {"TYPE": "String", "MINLENGTH": 2},
                        }
                    },
                }
            }

        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);

        t1.f3 = {};
        t1.f4 = {};
        var r = t1.getPlainValue();

        var status =  typeof r.f3 == "object" && typeof r.f4 == "undefined";
        t1.destruct();
        return status && countListeners()==0;
    }, true);

    runTest("Test simple de dictionary",
        "Pruebas de funcionamiento simple de diccionarios, incluyendo listeners",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Dictionary",
                    "SET_ON_EMPTY": true,
                    "VALUETYPE": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "sf3": {"TYPE": "String", "MINLENGTH": 2},

                        }
                    },
                },
                "f4": {
                    "TYPE": "Dictionary",
                    "VALUETYPE": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "sf3": {"TYPE": "String", "MINLENGTH": 2},
                        }
                    },
                }
            }

        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        var nChanges=0;
        t1["*f3"].addListener("CHANGE",function(){
            nChanges++;
        })
        t1.f3 = {uno: {sf3: "a1"}, dos: {sf3: "a2"}};
        t1.f3.tres={sf3:"a3"};
        t1.f3.cinco = {sf3: "a4"}
        var nKeys = 0;
        for (var k in t1.f3)
            nKeys++;
        var status = nKeys == 4 && t1.f3.cinco.sf3 == "a4" && nChanges==3;
        t1.destruct();
        return status && countListeners()==0;
    }, true);
    runTest("Test simple de dictionary (2)",
        "Se comprueba que no se disparan listeners en los objetos que mantienen copias",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Dictionary",
                    "SET_ON_EMPTY": true,
                    "VALUETYPE": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "sf3": {"TYPE": "String", "MINLENGTH": 2},

                        }
                    }
                }
            }

        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);

        var nChanges = 0;
        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges++
        });

        t1.f3 = {uno: {sf3: "a1"}, dos: {sf3: "a2"}};

        var h={};
        h.q=t1["*f3"].getValue();
        Siviglia.Path.eventize(h,"q");
        var nRefChanges=0;
        h["*q"].addListener("CHANGE",function(){nRefChanges++;});
        // Mientras siga siendo el mismo objeto, se deben seguir recibiendo eventos:
        t1.f3.tres={sf3:"cc"};
        var status=(nRefChanges==1 && nChanges==2);

        // Ahora se cambia el valor completamente.Esto no deberia generar eventos en h.q
        t1.f3={"cuatro":{sf3:"dd"},"cinco":{sf3:"ee"}};
        status = status && (nRefChanges==1 && nChanges==3);

        delete t1.f3.cuatro;
        var q=t1.f3.cuatro;
        var ss=t1.f3["[[KEYS]]"];
        status = status && ss.length==1 && (ss[0].LABEL=="cinco") &&
            (typeof t1.f3.cuatro === "undefined") &&
            (typeof t1.f3["*cuatro"] === "undefined");

        t1.destruct();

        // Sin embargo, hay que tener en cuenta que el listener de h.q es ahora "anonimo".
        // h.q no tiene un destruct (era un objeto plano), pero mantiene una referencia a un EventListener,
        // por lo que aun debe haber 1 listener activo.
        status = status && countListeners()==1;

        // Se limpian manualmente los listeners.
        Siviglia.Dom.existingListeners=[];
        return status;
    }, true);


    runTest("Comprobacion de DEFAULT en  TypeSwitcher (1)",
        "Prueba de vlor por defecto en TypeSwitcher",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "TypeSwitcher",
                    "TYPE_FIELD": "TYPE",
                    "CONTENT_FIELD": "value",
                    "ALLOWED_TYPES": {
                        "TIPO3": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "sf3": {"TYPE": "String", "MINLENGTH": 2},
                                "sf4": {"TYPE": "Integer"}
                            }
                        },
                        "TIPO4": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "sf1": {"TYPE": "String", "MINLENGTH": 2},
                                "sf2": {"TYPE": "Integer"}
                            }
                        }
                    },
                    "DEFAULT": {
                        "TYPE": "TIPO3",
                        "value": {
                            sf3: "aaa",
                            "sf4": 10
                        }
                    }
                },
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);

        var v = t1.f3.value.sf4;
        return v == 10;
    }, true);

    runTest("Comprobaciones de TypeSwitcher (1)",
        "Varias comprobaciones del funcionamiento normal de TypeSwitchers",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "TypeSwitcher",
                    "TYPE_FIELD": "TYPE",
                    "CONTENT_FIELD": "value",
                    "ALLOWED_TYPES": {
                        "TIPO3": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "sf3": {"TYPE": "String", "MINLENGTH": 2},
                                "sf4": {"TYPE": "Integer"}
                            }
                        },
                        "TIPO4": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "sf1": {"TYPE": "String", "MINLENGTH": 2},
                                "sf2": {"TYPE": "Integer"}
                            }
                        }
                    },
                    "DEFAULT": {
                        "TYPE": "TIPO3",
                        "value": {
                            sf3: "aaa",
                            "sf4": 10
                        }
                    }
                },
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        var nChanges = 0;
        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges++
        });
        // Comprobamos que, en este punto, ya que t1.f3.TYPE=="TIPO3" (por el valor por defecto),
        // existen sf3 y sf4:
        var initStatus = (t1.f3.value.sf3 === "aaa" && typeof t1.f3.value.sf2 == "undefined" && nChanges == 0);
        // Se cambia ahora el tipo del typeswitcher.Tienen que haber desaparecido los tipos anteriores,
        // y aparecer los nuevos campos, aunque esten a nulo.
        t1.f3.TYPE = "TIPO4";
        t1.f3.value={};
        var secondStatus = (t1.f3.value.sf1 == null && typeof t1.f3.value.sf3 == "undefined" && nChanges == 1);
        // Se deshace el cambio.
        t1.f3.TYPE = "TIPO3";
        t1.f3.value={};
        var thirdStatus = (t1.f3.value.sf3 == null && typeof t1.f3.value.sf1 == "undefined" && nChanges == 2);
        t1.destruct();
        return initStatus && secondStatus && thirdStatus && countListeners() === 0;
    }, true);

    runTest("Comprobaciones de TypeSwitcher (2)",
        "Mismas comprobaciones que el test anterior, pero sin 'CONTENT_FIELD' en el TypeSwitcher",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "TypeSwitcher",
                    "TYPE_FIELD": "TYPE",
                    "ALLOWED_TYPES": {
                        "TIPO3": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "sf3": {"TYPE": "String", "MINLENGTH": 2},
                                "sf4": {"TYPE": "Integer"}
                            }
                        },
                        "TIPO4": {
                            "TYPE": "Container",
                            "FIELDS": {
                                "sf1": {"TYPE": "String", "MINLENGTH": 2},
                                "sf2": {"TYPE": "Integer"}
                            }
                        }
                    },
                    "DEFAULT": {
                        "TYPE": "TIPO3",
                        sf3: "aaa",
                        "sf4": 10
                    }
                },
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
           def
        );
        // Comprobamos que, en este punto, ya que t1.f3.TYPE=="TIPO3" (por el valor por defecto),
        // existen sf3 y sf4:
        var initStatus = (t1.f3.sf3 === "aaa" && typeof t1.f3.sf2 == "undefined");
        // Se cambia ahora el tipo del typeswitcher.Tienen que haber desaparecido los tipos anteriores,
        // y aparecer los nuevos campos, aunque esten a nulo.
        t1.f3.TYPE = "TIPO4";
        var secondStatus = (t1.f3.sf1 == null && typeof t1.f3.sf3 == "undefined");
        // Se deshace el cambio.
        t1.f3.TYPE = "TIPO3";
        var thirdStatus = (t1.f3.sf3 == null && typeof t1.f3.sf1 == "undefined");
        t1.destruct();
        return initStatus && secondStatus && thirdStatus && countListeners() == 0;
    }, true);


    runTest("Comprobaciones de Array (1)",
        "Comprobaciones basicas de array, incluyendo gestores de eventos,chequeos de errores,etc",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Array",
                    "ELEMENTS": {"TYPE": "String", "MINLENGTH": 2}
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
          def
        );
        var firstStatus = (t1.f3 === null);
        var nErrors = 0;
        var nChanges = 0;

        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges++
        });
        var nExcp = 0;
        try {
            t1.f3 = ["u"];
        } catch (e) {
            nExcp++;
        }
        var secondStatus = ( nChanges == 0 && nExcp == 1);
        t1.f3 = ["uu"];
        var thirdStatus = (t1.f3.length == 1 && t1.f3[0] == "uu" && nChanges == 1);
        t1.destruct();
        return firstStatus && secondStatus && thirdStatus && countListeners() == 0;
    }, true);

    runTest("Comprobaciones de Array (2)",
        "Comprobaciones del funcionamiento correcto de los metodos de Array",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Array",
                    "ELEMENTS": {"TYPE": "String", "MINLENGTH": 2}
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
           def
        );
        var firstStatus = (t1.f3 === null);
        var nErrors = 0;
        var nChanges = 0;

        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges++
        });
        var nExcp = 0;
        try {
            t1.f3 = [];
            t1.f3.push("a");
        } catch (e) {
            nExcp++;
        }
        var secondStatus = (t1.f3.length == 0 && nChanges == 1 && nExcp == 1);
        t1.f3.push("aaa");
        var thirdStatus = (t1.f3.length == 1 && nChanges == 2 && nExcp == 1);
        t1.f3.shift();
        var fourthStatus = (t1.f3.length == 0 && nChanges == 3);
        t1.destruct();
        return firstStatus && secondStatus && thirdStatus && fourthStatus && countListeners() == 0;
    }, true);

    // Mismo test anterior, pero con objetos dentro del array.
    runTest("Comprobaciones de Array (3)",
        "Mismo test anterior, con elementos complejos de tipo Container.Se comprueban tambien los paths",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Array",
                    "ELEMENTS": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "sf1": {"TYPE": "String", "MINLENGTH": 2},
                            "sf2": {"TYPE": "Integer"}
                        }
                    }
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
           def
        );

        var nErrors = 0;
        var nChanges = 0;

        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges++
        });
        var nExcp = 0;
        try {
            t1.f3 = [{sf1: "a", sf2: 15}];
        } catch (e) {
            nExcp++;
        }
        var secondStatus = ( nChanges == 0 && nExcp == 1);
        t1.f3 = [{sf1: "aaa", sf2: 20}];
        var thirdStatus = (t1.f3.length == 1 && nChanges == 1 && nExcp == 1);
        var curPath = t1.f3[0]["*sf1"].__getFieldPath();
        var fourthStatus = (curPath == "/f3/0/sf1");
        t1.destruct();
        return secondStatus && thirdStatus && fourthStatus && countListeners() == 0;
    }, true);

    runTest("Comprobaciones de Array (4)",
        " Se comprueba que cuando se hace getValue() de un tipo, y se sobreescribe el tipo,\n" +
        "  no se reciben nuevos eventos.\n" +
        "  Supongamos un Array con valor [2,3,4]. Si alguien asigna a \"obj\" un getValue() de eso, se queda\n" +
        "  con ese array.Si al tipo Array se le asigna un nuevo valor ([5,6,7]), obj NO es notificado.\n" +
        "  Es decir, obj esta escuchando a su propia copia, no al BaseType.",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Array",
                    "ELEMENTS": {
                        "TYPE": "String"
                    }
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
            def
        );

        var nErrors = 0;
        var nChanges = 0;

        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges++
        });

        t1.f3=["aa","bb"];
        // Generamos una copia eventizada, para escuchar cambios.
        var h={};
        h.q=t1["*f3"].getValue();
        Siviglia.Path.eventize(h,"q");
        var nRefChanges=0;
        h["*q"].addListener("CHANGE",function(){nRefChanges++;});

        // Mientras siga siendo el mismo objeto, se deben seguir recibiendo eventos:
        t1.f3.push("cc");
        var status=(nRefChanges==1 && nChanges==2);

        // Ahora se cambia el valor completamente.Esto no deberia generar eventos en h.q
        t1.f3=["dd","ee","ff"];
        status = status && (nRefChanges==1 && nChanges==3);

        // Scomprobacion de path.
        var fPath=t1.f3["*0"].__getFieldPath();

        status=status && t1.f3["*0"].__getFieldPath()=="/f3/0";


        t1.destruct();

        // Sin embargo, hay que tener en cuenta que el listener de h.q es ahora "anonimo".
        // h.q no tiene un destruct (era un objeto plano), pero mantiene una referencia a un EventListener,
        // por lo que aun debe haber 1 listener activo.
        status = status && countListeners()==1;

        // Se limpian manualmente los listeners.
        Siviglia.Dom.existingListeners=[];




        return status && countListeners() == 0;
    }, true);

    runTest("Comprobaciones de Enum (1)",
        "Comprobaciones simples del tipo Enum",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Enum",
                    "VALUES": ["Value1", "Value2", "Value3"],
                    "DEFAULT": "Value3"
                }
            }
        },
        function (def) {

        var t1 = new Siviglia.model.BaseTypedObject(def);

        var nChanges = 0;
        var errored=0;
        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges++
        });
            t1["*f3"].addListener("ERROR", null, function () {
                    errored++;
            });
        var nExcp = 0;
        try {
            t1.f3 = "Value4";
        } catch (e) {
            nExcp++;
        }
        var secondStatus = (errored==1 && nChanges == 0 && nExcp == 1);
        t1.f3 = "Value1";
        var thirdStatus = (t1["*f3"].getLabel() == "Value1" && nChanges == 1 && nExcp == 1);
        t1.f3 = 2;
        var fourthStatus = (t1["*f3"].getLabel() == "Value3" && nChanges == 2 && nExcp == 1);

        t1.destruct();
        return secondStatus && thirdStatus && fourthStatus && countListeners() == 0;
    }, true);
    runTest("Comprobaciones de Integer",
        "Comprobaciones simples del tipo Integer",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Integer",
                    "MIN": 10,
                    "MAX": 20,
                    "DEFAULT": 15
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
           def
        );
        var nChanges = 0;
            var nErrors = 0;
        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges++

        });
        t1["*f3"].addListener("ERROR", null, function () {
            nErrors++
        });
        var nExcp = 0;

        var firstStatus = (t1.f3 == 15);
        try {
            t1.f3 = 8;
        } catch (e) {
            nExcp++;
        }
        var secondStatus = (nChanges == 0 && nExcp == 1 && nErrors==1);
        try {
            t1.f3 = 22;
        } catch (e) {
            nExcp++;
        }
        var secondStatus = (nChanges == 0 && nExcp == 2 && nErrors==2);
        t1.f3 = 16;
        var thirdStatus = (t1.f3 == 16 && nChanges == 1);


        t1.destruct();
        return firstStatus && secondStatus && thirdStatus && countListeners() == 0;
    }, true);
    runTest("Comprobaciones de String",
        "Comprobaciones de String, incluyendo regexes",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "String",
                    "MINLENGTH": 2,
                    "MAXLENGTH": 7,
                    "DEFAULT": "Valido"
                },
                "f4": {
                    "TYPE": "String",
                    "REGEXP": "/aa/"
                },

            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
            def
        );
        var nChanges = 0;
        var nErrors=0;
        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges++
        });
            t1["*f3"].addListener("ERROR", null, function () {
                nErrors++
            });
        t1["*f4"].addListener("CHANGE", null, function () {
            nChanges++
        });
            t1["*f4"].addListener("ERROR", null, function () {
                nErrors++
            });
        var nExcp = 0;
        var firstStatus = (t1.f3 == "Valido");
        try {
            t1.f3 = "a"
        } catch (e) {
            nExcp++;
        }
        var secondStatus = (nErrors==1 && nChanges == 0 && nExcp == 1);
        try {
            t1.f3 = "aaaaaaaa"
        } catch (e) {
            nExcp++;
        }
        var thirdStatus = (nErrors==2 && nChanges == 0 && nExcp == 2);
        t1.f3 = "bbb";
        var fourthStatus = (t1.f3 == "bbb" && nChanges == 1 && nExcp == 2);
        try {
            t1.f4 = "ccc";
        } catch (e) {
            nExcp++;
        }
        var fifthStatus = (nErrors==3 && nChanges==1 && nExcp == 3);
        t1.f4 = "aaaa";

        var sixthStatus = (t1.f4 == "aaaa" && nChanges == 2 && nExcp == 3 && nErrors==3);


        t1.destruct();
        return firstStatus && secondStatus && thirdStatus &&
            fifthStatus && sixthStatus && countListeners() == 0;
    }, true);


    runTest("Comprobaciones de DateTime",
        "Varias comprobaciones del funcionamiento del tipo DateTime, incluyendo limites, fechas pasadas y fechas futuras",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "DateTime",
                    "DEFAULT": "NOW"
                },
                "f4": {
                    "TYPE": "DateTime",
                    "STARTYEAR": 2000,
                    "ENDYEAR": 2020
                },
                "f5": {
                    "TYPE": "DateTime",
                    "STRICTLYPAST": true
                },
                "f6": {
                    "TYPE": "DateTime",
                    "STRICTLYFUTURE": true
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
        def
        );
        var convertDate = function (c) {
            var M = c.getMonth() + 1;
            var D = c.getDate();
            var H = c.getHours();
            var m = c.getMinutes();
            var s = c.getSeconds();
            M = (M < 10) ? ('0' + M) : M;
            D = (D < 10) ? ('0' + D) : D;
            H = (H < 10) ? ('0' + H) : H;
            m = (m < 10) ? ('0' + m) : m;
            s = (s < 10) ? ('0' + s) : s;
            return c.getFullYear() + '-' + M + '-' + D + ' ' + H + ':' + m + ':' + s;
        }
        var nChanges = 0;
        var nErrors=0;
        for(var k=3;k<=6;k++)
        {
            t1["*f"+k].addListener("CHANGE", null, function () {
                nChanges++
            });
            t1["*f"+k].addListener("ERROR", null, function () {
                nErrors++
            });
        }

        var nExcp = 0;
        var timestamp1 = t1["*f3"].getDateValue().getTime();
        var timestamp2 = (new Date()).getTime();
        var status = (timestamp2 - timestamp1 < 1000);

        try {
            t1.f4 = "1999-12-30 00:00:00";
        } catch (e) {
            nExcp++;
        }
        status = status && (nErrors==1 && nChanges == 0 && nExcp == 1);
        try {
            t1.f4 = "2021-01-01 00:00:00"
        } catch (e) {
            nExcp++;
        }
        status = status && (nErrors==2 && nChanges == 0 && nExcp == 2);
        t1.f4 = "2010-01-01 00:00:00";
        status = status && (t1.f4 == "2010-01-01 00:00:00" && nChanges == 1 && nExcp == 2);


        try {
            t1.f5 = "2050-01-01 00:00:00";
        } catch (e) {
            nExcp++;
        }
        status = status && (nErrors==3 && nExcp == 3);
        t1.f5 = "2010-01-01 00:00:00";
        status = status && (t1.f5 == "2010-01-01 00:00:00" && nChanges == 2 && nExcp == 3);

        try {
            t1.f6 = "2010-01-01 00:00:00";
        } catch (e) {
            nExcp++;
        }
        status = status && (nErrors==4 && nExcp == 4);
        t1.f6 = "2050-01-01 00:00:00";
        status = status && (t1.f6 == "2050-01-01 00:00:00" && nChanges == 3 && nExcp == 4);


        var res = convertDate(t1["*f6"].getDateValue())
        status = status && (res == t1.f6);
        t1.destruct();
        return status;
    }, true);

    runTest("Source de Enum (1)",
        "Comprobacion del funcionamiento de fuentes del tipo Enum (que, por debajo utiliza sources de tipo Array)",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Enum",
                    "VALUES": ["Value1", "Value2", "Value3"],
                    "DEFAULT": "Value3"
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        var source = t1["*f3"].__getSource();
        var loaded = 0;
        var changed = 0;
        var data = null;
        source.addListener("EVENT_LOADED", null, function () {
            loaded = 1;
        });
        source.addListener("CHANGE", null, function (ev, params) {
            changed = 1;
            console.dir(params);
            data = params.value
        });
        source.fetch();
        t1.destruct();
        return loaded === 1 && changed === 1 && data.length === 3 && data[2]["LABEL"] === "Value3" && data[2]["VALUE"] === 2 && countListeners() === 0;
    }, true);


    runTest("Sources de String (Array)",
        "Se comprueba el funcionamiento de un Source sobre un tipo String. Se utiliza para que, aunque un campo sea una simple String, su valor tenga que estar incluido en una fuente. Esto lo hace ligeramente parecido a los Enum, aunque en los Enum hay un valor numerico asociado, y en los Strings con source, no.",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "String",
                    "SOURCE": {
                        "TYPE": "Array",
                        "VALUES": ["Value1", "Value2", "Value3"],
                        "LABEL": "LABEL",
                        "VALUE": "LABEL"
                    }
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);

        var changed = 0;
        var source = t1["*f3"].__getSource();
        source.addListener("CHANGE", null, function (ev, params) {
            changed = 1;
        });
        var nExcp = 0;
        try {
            t1.f3="Value4";
            t1.save();

        } catch (e) {
            nExcp++;
        }
        var status = nExcp === 1;

        t1.f3="Value3";
        t1.save();
        status = status && t1.f3 === "Value3" && changed == 1;
        t1.destruct();
        return status && countListeners() == 0;
    }, true);

    runTest("Sources de String (Array Path)",
        "Comprobación de sources basadas en Path, para String. Se declaran campos cuyo valor depende de un path que se basa en hasta dos otros campos del mismo objeto,y el path, una vez sustituidos los campos, apunta a arrays que contienen los valores permitidos para el campo que contiene el path.",
        {
            "FIELDS": {
                "f1": {
                    "TYPE": "String",
                    "SOURCE": {
                        "TYPE": "Array",
                        "LABEL": "Label",
                        "VALUE": "Id",
                        "DATA": [
                            {"Label": "a", "Id": "a"},
                            {"Label": "d", "Id": "d"}
                        ]
                    }
                },
                "f2": {
                    "TYPE": "String",
                    "SOURCE": {
                        "TYPE": "Array",
                        "LABEL": "Label",
                        "VALUE": "Id",
                        "DATA": [
                            {"Label": "b", "Id": "b"},
                            {"Label": "c", "Id": "c"}
                        ]
                    }
                },
                "f3": {
                    "TYPE": "Integer",
                    "SOURCE": {
                        "TYPE": "Array",
                        "LABEL": "[%Label%] [%SubLabel%]",
                        "VALUE": "Id",
                        "DATA": {
                            "a": {
                                "b": [
                                    {"Id": 1, "Label": "Primero", "SubLabel": "1º"}
                                ],
                                "c": [
                                    {"Id": 2, "Label": "Segundo", "SubLabel": "2º"}
                                ]
                            },
                            "d": {
                                "c": [
                                    {"Id": 3, "Label": "Tercero", "SubLabel": "3º"},
                                    {"Id": 4, "Label": "Cuarto", "SubLabel": "4º"}
                                ]
                            }
                        },
                        "PATH": "/{#../f1}/{#../f2}"

                    }
                }
            }
        },
        function (def) {

        var btype = new Siviglia.model.BaseTypedObject(def);
        // Primera prueba: Si el source no esta listo, deben saltar excepciones.
        var nChanges = 0;
        var nValids=0;
        var curData = null;
        var nExcp=0;
        var s = btype["*f3"].__getSource(btype);
        s.addListener("CHANGE", function (evType, data) {
            nChanges++;
            if(data.valid)
                nValids++;
            curData = data.value;
        });
        try {

            btype.f3=155;
            btype.save();

        } catch (e) {
            nExcp++;
        }
        // Aqui no puede haber aun valor.
        var status = (nExcp===1 && nChanges===1 && nValids===0 && curData===null);

        // Cambiamos uno de los valores
        btype.f1 = "a";
        // Aun no se puede establecer el valor de f3
        try {

            btype.f3=155;
            btype.save();

        } catch (e) {
            nExcp++;
        }
        status = status && (nExcp===2 && nChanges===1 && nValids===0 && curData===null);

        btype.f2 = "b";
        // En cuanto se establece el valor de f2, tiene que haberse cargado los datos del source de f3
        status = status && (nChanges===2 && nValids===1 && curData!==null && curData.length==1 && curData[0].Id==1);

        // No se puede establecer el valor de f3 a 2, solo a 1:
        try {

            btype.f3=155;
            btype.save();

        } catch (e) {
            nExcp++;
        }
        status = status && (nExcp==3);

        btype.f3=1;
        btype.save();

        // Prueba dos : el fetch deberia devolver null, porque la combinacion f1=d y f2=b no esta soportada:

        btype.f1 = "d";

        status = status && (nChanges===3 && nValids===1 && curData==null);


        // Se cambia f2 a "c":
        btype.f2 = "c";

        status = status && (nChanges===4 && nValids===2 && curData!==null && curData.length==2 && curData[0].Id==3);

        btype.destruct();
        status = status && countListeners()==0;
        $n=11;
        return status;

    }, true);


    runTest("Source tipo PATH",
        "Pruebas de source de tipo path. Un campo entero apunta a otro campo, un array, que contiene los valores posibles. Se ve tambien como añadir listeners a los sources.",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "String",
                    "SOURCE":{
                        "TYPE":"Path",
                        "PATH":"#../f4/[[KEYS]]",
                        "LABEL":"LABEL",
                        "VALUE":"VALUE"
                    }
                },
                "f4": {
                    "TYPE": "Dictionary",
                    "VALUETYPE":{
                        "TYPE":"String"
                    }
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(
        def
        );
        var nChanges3 = 0;
        t1["*f3"].addListener("CHANGE", null, function () {
            nChanges3++
        });
        var nChanges4 = 0;
        t1["*f4"].addListener("CHANGE", null, function () {
            nChanges4++
        });
        var nExcp = 0;

        try{
            // Ojo, la siguiente linea va a disparar un onChange, porque el source se chequea a posteriori
            t1.f3="aa";
            // Y con el save, dara una excepcion
            t1.save();
        }catch(e)
        {
            nExcp++;
        }
        var nSources=0;
        t1["*f3"].__getSource().addListener("CHANGE",null,function(){
            nSources++;
        });
        t1.f4={"aa":"uno","bb":"dos"};
        var status=(nChanges4==1 && nChanges3==0 && nSources==1 );
        t1.f3="aa";
        t1.save();
        status = status && (nChanges3==1 && t1.f3=="aa");
        t1.f4["cc"]="tres";
        status=status && (nChanges4==2 && nSources==2);

        t1.f3="cc";
        t1.save();
        status=status && (nChanges3==2 && t1.f3=="cc");
        t1.destruct();
        status = status && countListeners()===0;
        return status;
    }, true);

    runTest("Source tipo Remoto",
        "Comprobacion de source de tipo remoto, mezclado con parametros en la URL que define el source. A diferencia de otros sources, los remotos solo se comprueban si el validationMode es COMPLETE, o cuando se hace el save().Hay que tener en cuenta que cuando este objeto esta vacio, y mientras no se asigna el valor que completa la URL, el source pueder llamar a onChange, pero estara marcado como invalid. Como al finalizar el test, lo que hay es una promesa que tiene que cumplirse, no estaran destruidos todos los listeners (no se ha destruido el basetypedobject) cuando se salga de la funcion. Se añade un then a la promesa, para destruir el bto con sus listeners.",
        {
            "FIELDS": {
                "f4":{
                    "TYPE":"String"
                },
                "f3": {
                    "TYPE": "Integer",
                    "SOURCE":{
                        "TYPE":"Url",
                        "URL":"/packages/Siviglia/tests/data/[%#../f4%].json",
                        "LABEL":"a",
                        "VALUE":"b"
                    }
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);

        var p=$.Deferred();
        var status=true;
        var s=t1["*f3"].__getSource();
        var nValid=0;
        var nChanged=0;
        var expectOk;
        s.addListener("CHANGE",function(ev,params){
            nChanged++;
            if(params.valid)
            {
                nValid++;
            }
            if(expectOk==1)
            {
                p.resolve(nValid===1);
            }
        });
        s.fetch();
        status=status && nChanged===1 && nValid===0;
        if(!status)
            return status;
        expectOk=1;
        t1.f4="data1";
        p.then(function(){t1.destruct()})
        return p;
    }, true);


    runTest("Tipo Custom Remoto, definido via Metadata",
        "Se crea un bto cuyo tipo es remoto (en este caso, un tipo metadata de String)",
        {
            "FIELDS": {
                "f4":{
                    "TYPE":"/model/reflection/Types/types/_String"
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.f4={"LABEL":"Probando"};
        return t1.f4.LABEL=="Probando";
    }, true);

    runTest("Tipo Custom Remoto: BaseType, definido via Metadata",
        "Un segundo test, cargando esta vez un objeto mucho más complejo (BaseType).Hay que fijarse en que hay que dar inicialmente un valor completo al campo, o sea, asignarle un objeto.No podemos asignar directamente un campo del objeto.Es decir, cuando se crea el bto, el campo f4 es undefined.Es por eso que no es posible hacer t1.f4.LABEL=... Hay primero que dar un valor a t1.f4 (como es normal en javascript).A partir de entonces, si se tiene acceso a los campos.",
        {
            "FIELDS": {
                "f4":{
                    "TYPE":"/model/reflection/Types/types/BaseType"
                }
            }
        },
        function (def) {
        var t1 = new Siviglia.model.BaseTypedObject(def);

        t1.f4={TYPE:"/model/reflection/Types/types/DateTime"};
        t1.f4.LABEL="Probando";
        t1.f4.TYPE.STRICTLYPAST=true;
        return t1.f4.LABEL=="Probando" && t1.f4["*STRICTLYPAST"].__definition.TYPE=="Boolean";
    }, true);
    runTest("Typeswitcher extended 1",
        "Especificacion de typeswitcher basados en el tipo de dato de un cierto campo existente en el valor asignado al TypeSwicther.Esto es, en la clave 'ON' del TypeSwitcher, existe un campo FIELD",
        {
            "FIELDS":{
                "f1":{
                    "TYPE":"TypeSwitcher",
                    // Array Object Exists Not exists
                    "ON":[{
                        "FIELD":"ft",
                        "IS":"Array",
                        "THEN":"TYPE1"
                    },
                        {
                            "FIELD":"ft",
                            "IS":"Object",
                            "THEN":"TYPE2"
                        }],
                    "ALLOWED_TYPES":{
                        "TYPE1":{
                            "TYPE":"Container",
                            "FIELDS":{
                                "ft": {
                                    "TYPE": "Array",
                                    "ELEMENTS":{"TYPE": "String"}
                                },
                                "f2":{
                                    "TYPE":"Boolean"
                                }
                            }
                        },
                        "TYPE2":{
                            "TYPE":"Container",
                            "FIELDS":{
                                "ft": {
                                    "TYPE": "Container",
                                    "FIELDS":{
                                        "s1":{"TYPE":"Integer"},
                                        "s2":{"TYPE":"Integer"},

                                    }
                                },
                                "f2":{
                                    "TYPE":"String"
                                }
                            }
                        }
                    }

                }
            }

        },
        function (def){
        var t1 = new Siviglia.model.BaseTypedObject(def);

        t1.setValue({"f1":{ft:["a","b","c"],"f2":true}});
        var st1=(JSON.stringify(t1.getPlainValue())=='{"f1":{"ft":["a","b","c"],"f2":true}}');
        t1.f1={"ft":{"s1":1,"s2":2}};
        st1=st1 && JSON.stringify(t1["*f1"].subNode.__definition)=='{"TYPE":"Container","FIELDS":{"ft":{"TYPE":"Container","FIELDS":{"s1":{"TYPE":"Integer"},"s2":{"TYPE":"Integer"}}},"f2":{"TYPE":"String"}}}';
        t1.f1.f2="Cambiado?";
        return st1;
    });

    runTest("Typeswitcher extended 2",
        "Se utiliza no solo el tipo, sino la existencia o no de un campo, para decidir el tipo del typeswitcher",
        {
            "FIELDS":{
                "f1":{
                    "TYPE":"TypeSwitcher",
                    // Array Object Exists Not exists
                    "ON":[{
                        "FIELD":"ft",
                        "IS":"Array",
                        "THEN":"TYPE1"
                    },
                        {
                            "FIELD":"aa",
                            "IS":"Present",
                            "THEN":"TYPE2"
                        }],
                    "ALLOWED_TYPES":{
                        "TYPE1":{
                            "TYPE":"Container",
                            "FIELDS":{
                                "ft": {
                                    "TYPE": "Array",
                                    "ELEMENTS":{"TYPE": "String"}
                                },
                                "f2":{
                                    "TYPE":"Boolean"
                                }
                            }
                        },
                        "TYPE2":{
                            "TYPE":"Container",
                            "FIELDS":{
                                "aa": {
                                    "TYPE": "Integer",
                                },
                                "f2":{
                                    "TYPE":"String"
                                }
                            }
                        }
                    }

                }
            }

        },
        function (def){
        var t1 = new Siviglia.model.BaseTypedObject(def);
        t1.setValue({"f1":{ft:["a","b","c"],"f2":true}});
        var st1=(JSON.stringify(t1.getPlainValue())=='{"f1":{"ft":["a","b","c"],"f2":true}}');
        t1.f1={aa:1};
        st1=st1 && JSON.stringify(t1["*f1"].subNode.__definition)=='{"TYPE":"Container","FIELDS":{"aa":{"TYPE":"Integer"},"f2":{"TYPE":"String"}}}';
        return st1;
    });

    runTest("Typeswitcher extended 3",
        "Especificacion de typeswitcher basados en el tipo de dato asignado al typeswitcher (y no de un cierto campo, como hace 2 tests).Esto es, en la clave 'ON' del TypeSwitcher, NO existe un campo FIELD",
        {
            "FIELDS":{
                "f1":{
                    "TYPE":"TypeSwitcher",
                    // Array Object Exists Not exists
                    "ON":[{
                        "IS":"Array",
                        "THEN":"TYPE1"
                    },
                        {
                            "IS":"String",
                            "THEN":"TYPE2"
                        }],
                    "ALLOWED_TYPES":{
                        "TYPE1":{
                            "TYPE":"Array",
                            "ELEMENTS":{
                                "TYPE": "String"
                            }
                        },
                        "TYPE2":{
                            "TYPE":"String"
                        }
                    }

                }
            }

        },
        function (def){

        var t1 = new Siviglia.model.BaseTypedObject(def);

        t1.setValue({"f1":"Hola?"});
        var st1=(JSON.stringify(t1.getPlainValue())=='{"f1":"Hola?"}');

        t1.setValue({"f1":["a","b","c"]});
        st1=st1 && JSON.stringify(t1["*f1"].subNode.__definition)=='{"TYPE":"Array","ELEMENTS":{"TYPE":"String"}}';
        t1.destruct();
        st1=st1 && countListeners()==0;
        return st1;
    });
    runTest("Array Serialization",
        "Se prueba la serializacion a json (getPlainValue), combinando diccionario/container/array",
        {
            "FIELDS": {
                "f2":{
                    "TYPE":"Dictionary",
                    "VALUETYPE":{

                        "TYPE": "Container",
                        "FIELDS":
                            {
                                "f4": {
                                    "TYPE": "Array",
                                    "ELEMENTS": {
                                        "TYPE": "Container",
                                        "FIELDS": {
                                            "sf1": {"TYPE": "String", "MINLENGTH": 2},
                                            "sf2": {"TYPE": "Integer"}
                                        }
                                    }
                                }
                            }

                    }
                }
            }
        },
        function (def){

        // Se crea una primera instancia, y se le asigna un valor:
        var t1 = new Siviglia.model.BaseTypedObject(def);
        var v=[{sf1:"aa",sf2:5},{sf1:"bb",sf2:15},{sf1:"cc",sf2:25}];
        t1.f2={aa:{f4:v}};

        var vv=JSON.stringify(t1.getPlainValue());
        var asserts=(vv==="{\"f2\":{\"aa\":{\"f4\":[{\"sf1\":\"aa\",\"sf2\":5},{\"sf1\":\"bb\",\"sf2\":15},{\"sf1\":\"cc\",\"sf2\":25}]}}}");
        t1.destruct();
        return asserts && countListeners()==0;
    });
    runTest("Array Reference Counter",
        "Pruebas de contador de referencias: Un array javascript es compartido por 2 BTOs, y la destruccion de los listeners debe ocurrir cuando ninguno de los dos btos apunta ya al array.Cambios en el array tienen que disparar 'onChange' en ambos BTOS",
        {
            "FIELDS": {
                "f3": {
                    "TYPE": "Integer",
                    "SOURCE":{
                        "TYPE":"Path",
                        "PATH":"#../f4",
                        "LABEL":"sf1",
                        "VALUE":"sf2"
                    }
                },
                "f4": {
                    "TYPE": "Array",
                    "ELEMENTS": {
                        "TYPE": "Container",
                        "FIELDS": {
                            "sf1": {"TYPE": "String", "MINLENGTH": 2},
                            "sf2": {"TYPE": "Integer"}
                        }
                    }
                }
            }
        },
        function (def){

        // Se crea una primera instancia, y se le asigna un valor:
        var t1 = new Siviglia.model.BaseTypedObject(def);
        var nChanges1=0;
        t1["*f4"].addListener("CHANGE",function(){nChanges1++});
        var v=[{sf1:"aa",sf2:5},{sf1:"bb",sf2:15},{sf1:"cc",sf2:25}];

        t1.f4=v;


        // Nos aseguramos de que solo se ha producido 1 change
        var asserts=(nChanges1==1);

        // Ahora v pasa a ser el valor de t1.f4:
        v=t1.f4;
        v.push({sf1:"dd",sf2:55});
        asserts=asserts && (nChanges1==2);
        // Creamos otra instancia con la misma definicion
        var nChanges2=0;
        var t2=new Siviglia.model.BaseTypedObject(def);
        t2["*f4"].addListener("CHANGE",function(){nChanges2++});
        t2.f4=v;

        asserts= asserts && (nChanges2==1);
        // Se comprueba que v ahora tiene 2 referencias:
        asserts= asserts && (v.__refcount__==2);
        // Cambiamos el valor de v, y vemos si se han llamado ambos listeners:
        v.push({sf1:"dd",sf2:55});
        asserts= asserts && (nChanges1==3 && nChanges2==2);
        // Destruimos t1, y vemos si se decrementa el contador de referencias:
        t1.destruct();
        asserts=asserts && (v.__refcount__==1 && v.__destroyed__==false);
        // Destruimos t2, y vemos si se decrementa el contador de referencias, y el objeto esta destruido.
        t2.destruct();
        asserts=asserts && (v.__refcount__==0 && v.__destroyed__==true);
        // Finalmente, nos aseguramos que despues de todo esto, el numero de listeners es cero.
        return asserts && countListeners()==0;
    });

    runTest("Accesos a traves de paths",
    "Se comprueba el acceso correcto a campos especificados por paths.ESTE EJEMPLO ES IMPORTANTE, porque en la version por el lado del servidor, NO ES NECESARIO dar un valor al container, para poder acceder a sus campos. Esto se hace asi, porque, mientras en PHP esto es codigo valido: $a['q']='hola''; el equivalente javascript, a.q='hola' da error, ya que hay que inicializar 'a' a un objeto.Por mantener la misma semantica que el lenguaje original, la libreria de tipos exige, antes de acceder a los campos, que el container padre tenga valor.",
        {
            "TYPE":"Container",
        "FIELDS": {
            "one": {"TYPE": "String", "MINLENGTH": 2, "MAXLENGTH": 10},
            "two": {"TYPE": "String", "DEFAULT": "Hola"}
        }
        },
    function(def)
    {
        var cnt = Siviglia.types.TypeFactory.getType({"fieldName":"a","path":"/"},def,null,null);
        var p=cnt.__getFieldPath();
        var status=(p==="/a");
        cnt.setValue({});
        status = status && "/a/one"===cnt["*one"].__getFieldPath();
        return status;
    });

    runTest("Comprobaciones de campos dirty",
    "Diferentes comprobaciones de que los campos se establecen a dirty correctamente",
        {
            "TYPE":"Container",
        "FIELDS":{
        "one":{"TYPE":"String","REQUIRED":true},
    "two":{"TYPE":"String","REQUIRED":true},
    "state":{"TYPE":"State","VALUES":["E1","E2","E3"],"DEFAULT":"E1"}
    },
    'STATES' : {
        'STATES' : {
        'E1' : {
        'FIELDS' : {'EDITABLE' : ['one','two']}
    },
    'E2' : {
        'ALLOW_FROM':["E1"],
        'FIELDS' : {'EDITABLE' : ['two','three']}
    },
    'E3' : {
        'ALLOW_FROM':["E2"],
        'FINAL':true,
        'FIELDS' : {'REQUIRED' : ['three']}}
    },
    'FIELD' : 'state'
    }
    },
        function(def)
        {
            var cnt = Siviglia.types.TypeFactory.getType({"fieldName":"a","path":"/"},def,null,null);
            var status=cnt.isDirty()===false && cnt.__hasOwnValue()===false;
            cnt.setValue({"one":"aa","two":"bbb"});
            status = status && cnt["*one"].isDirty();
            var dFields=cnt.getDirtyFields();
            var keys=[];
            for(var k=0;k<dFields.length;k++)
                keys.push(dFields[k].__getFieldName());
            status=status && keys.length==2;
            status=status && keys.indexOf("one")>=0 && keys.indexOf("two")>=0;
            return status;
        }
    );
    
    runTest("Comprobaciones de campos dirty anidados",
            "Se comprueba que los campos dirty son asignados cada uno a su controller, con los paths correctos",
            {
                "TYPE":"Container",
                "FIELDS":{
                    "one":{"TYPE":"String","REQUIRED":true},
                    "two":{"TYPE":"String","REQUIRED":true},
                    "state":{"TYPE":"State","VALUES":["E1","E2","E3"],"DEFAULT":"E1"},
                    "inner":{
                        "TYPE":"Container",
                        "REQUIRED":true,
                        "FIELDS":{
                            "one":{"TYPE":"String","REQUIRED":true},
                            "two":{"TYPE":"String","REQUIRED":true},
                            "state":{"TYPE":"State","VALUES":["E1","E2","E3"],"DEFAULT":"E1"}
                        },
                        'STATES' : {
                            'STATES' : {
                                'E1' : {
                                    'FIELDS' : {'EDITABLE' : ['one','two']}
                                },
                                'E2' : {
                                    'ALLOW_FROM':["E1"],
                                    'FIELDS' : {'EDITABLE' : ['two','three']}
                                },
                                'E3' : {
                                    'ALLOW_FROM':["E2"],
                                    'FINAL':true,
                                    'FIELDS' : {'REQUIRED' : ['three']}}
                            },
                            'FIELD' : 'state'
                        }
                    }
                },
                'STATES' : {
                    'STATES' : {
                        'E1' : {
                            'FIELDS' : {'EDITABLE' : ['one','two']}
                        },
                        'E2' : {
                            'ALLOW_FROM':["E1"],
                            'FIELDS' : {'EDITABLE' : ['two','three']}
                        },
                        'E3' : {
                            'ALLOW_FROM':["E2"],
                            'FINAL':true,
                            'FIELDS' : {'REQUIRED' : ['three']}}
                    },
                    'FIELD' : 'state'
                }
        },
        function(def)
        {
            var cnt = Siviglia.types.TypeFactory.getType({"fieldName":"a","path":"/"},def,null,null);
            var status=cnt.isDirty()===false && cnt.__hasOwnValue()===false;


            // Asignamos un campo del container interno.
            // Esto tiene que hacer que ambos containers se pongan a sucio, pero ninguno de los dos tiene valor
            cnt.setValue({"inner":{"one":"aa","two":"zzz"},"one":"aaa","two":"bbb"});
            status = status && cnt.isDirty() && cnt["*inner"].isDirty();

            // Ademas, ambos campos tienen que tener campos sucios:
            // Desde el container externo, es el container interno el que esta sucio.
            var dFields=cnt.getDirtyFields();
            var foundInner=false;
            for(var k=0;k<dFields.length;k++){
                    if(dFields[k].__getFieldName()=="inner")
                        foundInner=true;
                }
            status = status && foundInner && 3===dFields.length;


            // Desde el container interno, es el campo "/one" el que esta sucio.
            dFields=cnt["*inner"].getDirtyFields();
            var foundOne=false;
            var foundTwo=false;
            for(var k=0;k<dFields.length;k++){
                if(dFields[k].__getFieldName()=="one")
                    foundOne=true;
                    if(dFields[k].__getFieldName()=="two")
                    foundTwo=true;
                }
            status=status && dFields.length==2 && foundOne && foundTwo;
            return status;
        });

        runTest(
            "Comprobaciones basicas de estado",
            "En este test, se introducen muchas aserciones sobre la API basica de estado, por no crear un test separado por cada cosa a probar. De nuevo, aqui hay una diferencia grande con respecto al servidor: Hay que darle un valor al container para poder preguntar por su estado.",
            {
                "TYPE":"Container",
                "FIELDS":{
                    "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":10},
                    "two":{"TYPE":"String","DEFAULT":"Hola"},
                    "three":{"TYPE":"String"},
                    "four":{"TYPE":"String"},
                    "state":{"TYPE":"State","VALUES":["E1","E2","E3"],"DEFAULT":"E1"}
                },
                'STATES' : {
                    'STATES' : {
                        'E1' : {
                            'FIELDS' : {'EDITABLE' : ['one','two']}
                        },
                        'E2' : {
                            'ALLOW_FROM':["E1"],
                            'FIELDS' : {'EDITABLE' : ['two','three']}
                        },
                        'E3' : {
                            'ALLOW_FROM':["E2"],
                            'FINAL':true,
                            'FIELDS' : {'REQUIRED' : ['three']}}
                    },
                    'FIELD' : 'state'
                }
            },
            function(def)
            {
                /* Aqui se van a comprobar todas las funcionalidades basicas de estado. Se va a hacer en un solo test para
     no repetir continuamente la misma definicion, alargando este fichero. */
                var cnt = Siviglia.types.TypeFactory.getType({"fieldName":"a","path":"/"},def,null,null);
                // Se asigna un valor vacio para poder tener acceso a los campos.
                cnt.setValue({});
                var st=cnt.getStateDef();
                var status= st!==null;
                                    
                    status=status && "E1"===st.getCurrentStateLabel();
                    status = status && "state"===st.getStateField();
                    status = status && true===st.hasStates();
                    status = status && JSON.stringify(def["STATES"])===JSON.stringify(st.getStates());
                    status = status && "E1"===st.getDefaultState();
                    status = status && cnt["*state"]===st.getStateFieldObj();
                    status = status && 0===st.getStateId("E1");
                    status = status && 2===st.getStateId("E3");
                    status = status && false===st.isFinalState("E1");
                    status = status && true===st.isFinalState("E3");
                    status = status && "E1"===st.getStateLabel(0);
                    status = status && "E3"===st.getStateLabel(2);
                    status = status && "E1"===st.getCurrentStateLabel();
                    // Nos saltamos por ahora los tests de checkState.
                    status = status && true===st.isEditable("one");
                    status = status && true===st.isEditable("two");
                    // Los metodos de isRequired y isFixed, en realidad usan los siguientes metodos. Testear estos metodos es
                    // "equivalente" a testear los otros.
                    status = status && true===st.isEditableInState("one","E1");
                    status = status && true===st.isEditableInState("two","E1");
                    status = status && false===st.isEditableInState("one","E2");
                    // Comprobamos que tambien funcionan con paths
                    status = status && false===st.isEditableInState("/one","E2");
                    status = status && true===st.isEditableInState("state","E2");
                    status = status && false===st.isRequiredForState("three","E1");
                    status = status && true===st.isRequiredForState("three","E3");
                    status = status && false===st.isRequiredForState("one","E1");
                    status = status && false===st.isRequiredForState("three","E1");
                    // Por ahora, no vamos a soportar campos FIXED. No esta clara su utilidad, y su especificacion es diferente
                    // a EDITABLE y REQUIRED, lo que añade una ligera complicacion.
                    //status = status && true,st.isFixedInState("four","E2");
                    //status = status && false,st.isFixedInState("four","E1");
                    // Todos los metodos anteriores, han hecho uso de existsFieldInStateDefinition, por lo que no lo probamos.

                    status = status && false===st.isEditableInState("one","E2");
                    // El siguiente metodo descriptivo es:
                    status = status && null===st.getStateTransitions(0);
                    var st1=st.getStateTransitions(1);
                    status = status && st1.length==1 && st1[0]==0;
                    var st2=st.getStateTransitions(2);
                    status = status && st2.length==1 && st2[0]==1;
                    // Siguiente : canTranslateTo
                    status = status && true===st.canTranslateTo(1);
                    status = status && false===st.canTranslateTo(2);
                    // Siguiente: getRequiredFields
                    status = status && st.getRequiredFields("E1").length===0;
                    var reqFields=st.getRequiredFields("E3");
                    status = status && "three"===reqFields[0];
                    return status;
            }
        );
    runTest(
        "Comprobaciones functionales de estado",
        "Se ejecutan operaciones dependientes de estado, para comprobar que campos requeridos, transiciones posibles, etc, se respetan.",
        {
            "TYPE":"Container",
            "FIELDS":{
                "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":10},
                "two":{"TYPE":"String","DEFAULT":"Hola"},
                "three":{"TYPE":"String"},
                "four":{"TYPE":"String"},
                "state":{"TYPE":"State","VALUES":["E1","E2","E3"],"DEFAULT":"E1"}
            },
            'STATES' : {
                'STATES' : {
                    'E1' : {
                        'FIELDS' : {'EDITABLE' : ['one','two']}
                    },
                    'E2' : {
                        'ALLOW_FROM':["E1"],
                        'FIELDS' : {'EDITABLE' : ['two','three']}
                    },
                    'E3' : {
                        'ALLOW_FROM':["E2"],
                        'FINAL':true,
                        'FIELDS' : {'REQUIRED' : ['three']}}
                },
                'FIELD' : 'state'
            }
        },
        function(def) {

            var cnt = Siviglia.types.TypeFactory.getType({"fieldName": "a", "path": "/"}, def, null, null);
            // Se asigna un valor vacio para poder tener acceso a los campos.
            // Estamos en el estado inicial, que debe ser "E1", por ser el valor por defecto.
            // En este estado, "one" y "two" son editables:
            cnt.setValue({"one":"AAA","two":"BBB"});
            // Hasta aqui no deben haber saltado excepciones.De hecho, por debajo deberia haberse completado el estado,
            // Ahora si que deberia saltar una excepcion, al modificar un campo que no esta definido como editable:
            var thrown=false;
            var result=true;
            try {
                cnt.three = "CCC";
            }catch(e)
            {
                thrown=true;
                result=result && (e.type=="BaseTypeException" && e.code==Siviglia.model.BaseTypedException.ERR_NOT_EDITABLE_IN_STATE);
            }
            result=result && thrown;

            // Ahora se comienza un cambio de estado.Aqui se va a probar un cambio de estado realizado a base de
            // asignar campos uno a uno, en vez de darle valor a todo el container.Eso tendra que hacerse en una prueba posterior.
            cnt.state="E2";
            // Intentamos editar de nuevo el campo "one", pero no es editable en este estado.
            thrown=false;
            try {
                cnt.one = "CCC";
            }catch(e)
            {
                thrown=true;
                result=result && (e.type=="BaseTypeException" && e.code==Siviglia.model.BaseTypedException.ERR_NOT_EDITABLE_IN_STATE);
            }
            result=result && thrown;

            // Ahora, se va a intentar cambiar al siguiente estado, E3, pero deberia dar una excepcion, ya que
            // el campo three es requerido en el estado E3:
            thrown=false;
            try {
                cnt.state="E3";
            }catch(e)
            {
                result=result && (e.type=="BaseTypeException" && e.code==Siviglia.model.BaseTypedException.ERR_REQUIRED_FIELD);
                thrown=true;
            }
            result=result && thrown;

            // Rellenamos el campo faltante, y esperamos que esta vez si que se acepte el cambio de estado
            cnt.three="www";
            thrown=false;
            try {
                cnt.state = "E3";
            }catch(e)
            {
                thrown=true;
            }
            result=result && thrown===false;

            // Ahora estamos en un estado final. No deberia ser posible movernos de este estado, por dos motivos:
            // porque ningun otro estado lo tiene en el ALLOW_FROM, y porque es un estado final. Pero es esta
            // condicion la que debe saltar primero.
            thrown=false;
            try {
                cnt.state = "E2";
            }catch(e)
            {
                result=result && (e.type=="BaseTypeException" && e.code==Siviglia.model.BaseTypedException.ERR_CANT_CHANGE_FINAL_STATE);
                thrown=true;
            }
            return result && thrown;
        });
    runTest(
        "Comprobaciones functionales de estado (2)",
        "Test identico al anterior,pero los cambios de estado se provocan asignando valores completos al container, no campo a campo.",
        {
            "TYPE":"Container",
            "FIELDS":{
                "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":10},
                "two":{"TYPE":"String","DEFAULT":"Hola"},
                "three":{"TYPE":"String"},
                "four":{"TYPE":"String"},
                "state":{"TYPE":"State","VALUES":["E1","E2","E3"],"DEFAULT":"E1"}
            },
            'STATES' : {
                'STATES' : {
                    'E1' : {
                        'FIELDS' : {'EDITABLE' : ['one','two']}
                    },
                    'E2' : {
                        'ALLOW_FROM':["E1"],
                        'FIELDS' : {'EDITABLE' : ['two','three']}
                    },
                    'E3' : {
                        'ALLOW_FROM':["E2"],
                        'FINAL':true,
                        'FIELDS' : {'REQUIRED' : ['three']}}
                },
                'FIELD' : 'state'
            }
        },
        function(def) {
            var cnt = Siviglia.types.TypeFactory.getType({"fieldName": "a", "path": "/"}, def, null, null);
            var thrown=false;
            var result=true;
            try {
                cnt.setValue({
                    "state": "E1",
                    "one": "AAA",
                    "two": "BBB"
                });
            }catch(e)
            {
                thrown=true;
            }
            result=result && false===thrown;
            result=result && 0===cnt.state;
            result=result && "BBB"===cnt.two;

            // en setValue, no tiene por que haber problemas por establecer un valor incorrecto, siempre que la validacion este a NO_VALIDATION
            // Aqui, se establece un tipo incompleto (setValue)
            // Sin embargo, si que tiene que dar problemas si el tipo de validacion no es none:
            thrown=false;
            try {
                cnt.setValue({"state":"E3", "one":"AAA"}, Siviglia.types.BaseType.VALIDATION_MODE_COMPLETE);
            }catch(e)
            {
                thrown=true;
                result=result && (e.type=="BaseTypeException" && e.code==Siviglia.model.BaseTypedException.ERR_REQUIRED_FIELD);
            }
            result=result && true==thrown;

            // LLamando a apply, no a setValue, podemos poner el mismo valor, aunque sea incorrecto.
            // Aqui, no se está estableciendo el campo three, que es required en ese estado.
            cnt.apply({"state":"E3","one":"AAA"},Siviglia.types.BaseType.VALIDATION_MODE_NONE);
            result=result && 2===cnt.state;
            result=result && null===cnt.three;
            result=result && "AAA"===cnt.one;
            return result;

        });
    /*
         COMIENZAN LOS TESTS ASOCIADOS AL FICHERO /lib/tests/model/BaseTypedObjectTest
          
     */
    Siviglia.Utils.buildClass(
        {
            "context": "Test",
            "classes": {
                "Definitions":{
                    "methods":{
                        getDefinition1:function()
                        {
                            return  {
                                "FIELDS":{"one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4}}
                            };
                        },
                        getDefinition2:function()
                        {
                            return {
                                "FIELDS":{
                                    "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "two":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "three":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "four":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "five":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "status":{'TYPE' : 'State',
                                        'VALUES' : [
                                            'None', 'Other', 'Another'
                                        ],
                                        'DEFAULT' : 'None'}
                                },
                                'STATES' : {
                                    'STATES' : {
                                        'None' : {
                                            'FIELDS' : {
                                                'EDITABLE' : ['one','three','five']
                                            }
                                        },
                                        'Other' : {
                                            'ALLOW_FROM':["None"],
                                            'FIELDS' : {
                                                'EDITABLE' : ['two'],
                                                'FIXED' : ['one']}
                                        },
                                        'Another' : {'FIELDS' : {
                                                'EDITABLE' : ['one'],
                                                'REQUIRED' : ['three']
                                            }
                                        },
                                        'Last' : {'FIELDS' : {
                                                'EDITABLE' : ['one'],
                                                'REQUIRED' : ['three']
                                            }
                                        }
                                    },
                                    'FIELD' : 'status',
                                    'DEFAULT' : 'None'
                                }
                            };
                        },
                        getDefinition4:function()
                        {

                            return {
                                "FIELDS":{
                                    "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "two":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "three":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "four":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "five":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "status":{'TYPE' : 'State',
                                        'VALUES' : [
                                            'None', 'Other', 'Another','Last'
                                        ],
                                        'DEFAULT' : 'None'}
                                },
                                'STATES' : {
                                    "LISTENER_TAGS":{
                                        "ONE":{"TYPE":"METHOD","METHOD":"callback_one"},
                                        "TWO":{"TYPE":"METHOD","METHOD":"callback_two"},
                                        "THREE":{"TYPE":"METHOD","METHOD":"callback_three"},
                                        "FAIL_TEST":{"TYPE":"METHOD","METHOD":"test_nok"},
                                        "TEST_OK":{"TYPE":"METHOD","METHOD":"test_ok"},
                                        "P_ONE":{"TYPE":"PROCESS","CALLBACKS":["ONE","TWO"]}
                                    },
                                    'STATES' : {
                                        'None' : {
                                            "LISTENERS":{
                                                "ON_LEAVE":{
                                                    "STATES":{"Other":["ONE"]},
                                                },
                                                "TESTS":["TEST_OK"]
                                            },
                                            'FIELDS' : {
                                                'EDITABLE' : ['one','three']
                                            }
                                        },
                                        'Other' : {
                                            'ALLOW_FROM':["None","Another"],
                                            "LISTENERS":{
                                                "ON_ENTER":{
                                                    "STATES":{
                                                        "None":["TWO"],
                                                        "Another":["THREE"]
                                                    }
                                                }
                                            },
                                            'FIELDS' : {
                                                'EDITABLE' : ['two','three'],
                                                'FIXED' : ['one']}
                                        },
                                        'Another' : {
                                            "LISTENERS":{

                                                "TESTS":["FAIL_TEST"]
                                            },
                                            'FIELDS' : {
                                                'EDITABLE' : ['one'],
                                                'REQUIRED' : ['three']
                                            }
                                        },
                                        'Last' : {

                                            "FINAL":1,
                                            "LISTENERS":{
                                                "ON_ENTER":{
                                                    "STATES":{"None":["THREE","P_ONE"]},
                                                },
                                                "TESTS":["TEST_OK"]
                                            },
                                            'FIELDS' : {
                                                'EDITABLE' : ['one'],
                                                'REQUIRED' : ['three']
                                            }
                                        }
                                    },
                                    'FIELD' : 'status',
                                    'DEFAULT' : 'None'
                                }
                            };

                        },

                        getDefinition5:function()
                        {

                            return {
                                "FIELDS":{
                                    "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "two":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "three":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "four":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "five":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                    "status":{'TYPE' : 'State',
                                        'VALUES' : [
                                            'None', 'Other', 'Another','Last'
                                        ],
                                        'DEFAULT' : 'None'}
                                },
                                'STATES' : {
                                    "LISTENER_TAGS":{
                                        "ONE":{"TYPE":"METHOD","METHOD":"callback_one"},
                                        "TWO":{"TYPE":"METHOD","METHOD":"callback_two","PARAMS":["set"]},
                                        "THREE":{"TYPE":"METHOD","METHOD":"callback_three"},
                                        "FAIL_TEST":{"TYPE":"METHOD","METHOD":"test_nok"},
                                        "TEST_OK":{"TYPE":"METHOD","METHOD":"test_ok"},
                                        "P_ONE":{"TYPE":"PROCESS","CALLBACKS":["ONE","TWO"]},

                                    },
                                    'STATES' : {
                                        'None' : {
                                            "LISTENERS":{
                                                "ON_LEAVE":{
                                                    "STATES":{
                                                        "Other":["ONE"],
                                                        "*":["TWO"]
                                                    },
                                                },
                                                "TESTS":["TEST_OK"]
                                            },
                                            'FIELDS' : {
                                                'EDITABLE' : ['one','three']
                                            }
                                        },
                                        'Other' : {
                                            'ALLOW_FROM':["None","Another"],
                                            "LISTENERS":{
                                                "ON_ENTER":["THREE"]
                                            },
                                            'FIELDS' : {
                                                'EDITABLE' : ['two'],
                                                'FIXED' : ['one']}
                                        },
                                        'Another' : {
                                            "LISTENERS":{
                                                "ON_ENTER":{
                                                    "STATES":{"None":["THREE","P_ONE"]},
                                                },
                                                //"TESTS":{"FAIL_TEST"}
                                            },
                                            'FIELDS' : {
                                                'EDITABLE' : ['one'],
                                                'REQUIRED' : ['three']
                                            }
                                        },
                                        'Last' : {
                                            "FINAL":1,
                                            "LISTENERS":{
                                                "TESTS":["TEST_OK"]
                                            },
                                            'FIELDS' : {
                                                'EDITABLE' : ['one'],
                                                'REQUIRED' : ['three']
                                            }
                                        }
                                    },
                                    'FIELD' : 'status',
                                    'DEFAULT' : 'None'
                                }
                            };
                        },

                        getDefinition6:function()
                        {
                            return {
                                "FIELDS":{
                                    "one":{"TYPE":"String"},
                                    "arr":{"TYPE":"Array","ELEMENTS":{
                                            "TYPE":"String"
                                        }},
                                    "dict":{"TYPE":"Container",
                                        "FIELDS":{
                                            "c1":{"TYPE":"String"},
                            "c2":{"TYPE":"Array",
                            "ELEMENTS":{
                            "TYPE":"String"
                        }
                        }
                        }
                        }
                        }
                        }

                    },
                    getDefinition7:function()
                    {
                        /**
                         * Ojo, que seven tiene un metodo get_ en SimpleTypedObject, y eight tiene un metodo
                         * check_ y process_.
                         * El metodo check_eight requiere que la cadena tenga mas de 3 caracteres.
                         */
                        return {
                            "FIELDS":{
                                "seven":{"TYPE":"String"},
                                "eight":{"TYPE":"String"}
                            }
                        };
                    },

                    // La definicion 8 es parecida a la definicion 4, pero sin
                    // restricciones, para probar la validacion
                    getDefinition8:function()
                    {
                        return {
                            "FIELDS":{
                                "one":{"TYPE":"String"},
                                "two":{"TYPE":"String"},
                                "three":{"TYPE":"String"},
                                "four":{"TYPE":"String"},
                                "five":{"TYPE":"String"},
                                "status":{'TYPE' : 'Enum',
                                    'VALUES' : [
                                        'None', 'Other', 'Another','Last'
                                    ],
                                    'DEFAULT' : 'None'}
                            },

                        };
                    },
                    getDefinition9:function()
                    {

                        return {
                            "FIELDS":{
                                "one":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                "two":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                "three":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                "four":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                "five":{"TYPE":"String","MINLENGTH":2,"MAXLENGTH":4},
                                "status":{'TYPE' : 'State',
                                    'VALUES' : [
                                        'None', 'Other', 'Another','Last'
                                    ],
                                    'DEFAULT' : 'None'}
                            },
                            'STATES' : {
                                "LISTENER_TAGS":{
                                    "ONE":{"TYPE":"METHOD","METHOD":"callback_one"},
                                    "TWO":{"TYPE":"METHOD","METHOD":"callback_two","PARAMS":["set"]},
                                    "THREE":{"TYPE":"METHOD","METHOD":"callback_three"},
                                    "FAIL_TEST":{"TYPE":"METHOD","METHOD":"test_nok"},
                                    "TEST_OK":{"TYPE":"METHOD","METHOD":"test_ok"},
                                    "P_ONE":{"TYPE":"PROCESS","CALLBACKS":["ONE","TWO"]},
                                    "ENTERING_OK":{"TYPE":"METHOD","METHOD":"enteringState"},

                                },
                                'STATES' : {
                                    'None' : {
                                        "LISTENERS":{
                                            "ON_LEAVE":{
                                                "STATES":{
                                                    "Other":["ONE"],
                                                    "*":["TWO"]
                                                },
                                            },
                                            "TESTS":["TEST_OK"]
                                        },
                                        'FIELDS' : {
                                            'EDITABLE' : ['one','three']
                                        }
                                    },
                                    'Other' : {
                                        'ALLOW_FROM':["None","Another"],
                                        "LISTENERS":{
                                            "ON_ENTER":["THREE"]
                                        },
                                        'FIELDS' : {
                                            'EDITABLE' : ['two'],
                                            'FIXED' : ['one']}
                                    },
                                    'Another' : {
                                        "LISTENERS":{
                                            "ON_ENTER":{
                                                "STATES":{"None":["ENTERING_OK"]},
                                            },
                                            //"TESTS":{"FAIL_TEST"}
                                        },
                                        'FIELDS' : {
                                            'EDITABLE' : ['one'],
                                            'REQUIRED' : ['three']
                                        }
                                    },
                                    'Last' : {
                                        "FINAL":1,
                                        "LISTENERS":{
                                            "TESTS":["TEST_OK"]
                                        },
                                        'FIELDS' : {
                                            'EDITABLE' : ['one'],
                                            'REQUIRED' : ['three']
                                        }
                                    }
                                },
                                'FIELD' : 'status',
                                'DEFAULT' : 'None'
                            }
                        };

                    }

                }
                },
                "SimpleTypedObject": {
                    inherits:'Siviglia.model.BaseTypedObject',
                    construct:function(def)
                    {
                        this.__one=null;
                        this.__two=null;
                        this.__three=null;
                        this.__four=null;
                        this.__five=null;
                        this.__testedOk=false;
                        this.__testedNok=false;
                        this.__enteringCalled=false;
                        this.BaseTypedObject(def);
                    },
                    methods:{
                        check_five:function(value){if(value=="five")return true;return false;},
                        process_five:function(value){return "six";},
                        callback_one:function(){this.__one="one";},
                        callback_two:function(){this.__two="set";},
                        callback_three:function(){this.__three="three";},
                        callback_four:function(){this.__four="four";},
                        test_ok:function(){this.__testedOk=true;return true;},
                        test_nok:function(){this.__testedNok=true;return false;},
                        get_seven:function(){return "seven";},
                        check_eight:function(value){return value.length>3;},
                        process_eight:function(value){return value+"##";},
                        enteringState:function(){this.__enteringCalled=true;return true;}
                    }
                }
            }
        }
    )
  var defInstance=new Test.Definitions();
    d1 = defInstance.getDefinition2();
    runTest(
        "Comprobacion simple de campo sucio",
        "Prueba de contabilizacion correcta de campos sucios",
        d1
        ,
        function(def) {
            /* Aqui se van a comprobar todas las funcionalidades basicas de estado. Se va a hacer en un solo test para
 no repetir continuamente la misma definicion, alargando este fichero. */
            var ob= new Siviglia.model.BaseTypedObject(def);
            ob.one="hola";
            var result="hola"===ob["*one"].getValue();
            result = result && true===ob.isDirty();
            var inf=ob.getDirtyFields();

            result=result && "one"===inf[0].__getFieldName();
            result=result && 1===inf.length;
            return result;
        });
    d1 = defInstance.getDefinition2();
    runTest(
        "Comprobacion simple de campo con error",
        "Se crea un BTO y se asigna un campo a un valor no valido.Se comprueba la excepcion, y que el campo se ha marcado como con error.Se le asigna después un valor correcto, y se comprueba que la condición de error se ha limpiado.",
        d1
        ,
        function(def) {
            var obj= new Siviglia.model.BaseTypedObject(def);
            obj.one="one";
            var thrown=false;
            var result=true;
            try{
                obj.one="w";
            }catch(e)
            {
                thrown=true;
                result=result && (e.type=="StringException" && e.code==Siviglia.types.StringException.ERR_TOO_SHORT);
            }
            result=result && true==thrown;
            result=result && true==obj.__isErrored();
            var errored=obj.getErroredFields();
            result=result && 1==errored.length;
            result=result && true==obj["*one"].__isErrored();
            result=result && true==obj["*one"].__getError()!==null;
            result=result && "/one"==errored[0].__getFieldPath();
            // Le damos ahora un valor valido. Deberia borrarse el error.
            obj.one="ssss";
            result=result && false==obj["*one"].__isErrored();
            result=result && null==obj["*one"].__getError();
            result=result && false==obj.__isErrored();
            return result;
    });
    d1 = defInstance.getDefinition2();
    runTest(
        "Comprobacion de errores generados por cambios de estado",
        "Se comprueba que los errores generados por cambios de estado, se asignan correctamente a los campos que los generan.",
        d1
        ,
        function(def) {
            var obj= new Siviglia.model.BaseTypedObject(def);
            var result="status"==obj.getStateField();
            result=result && 'None'==obj["*status"].getLabel();
            obj.three="thr";
            var thrown=false;
            obj.setValue({"status": "None", "three": "qq", "one" : "lala"});
            try {
                obj.two="hola";
            }catch(e) {
                thrown=true;
                result=result && (e.type=="BaseTypeException" && e.code==Siviglia.model.BaseTypedException.ERR_NOT_EDITABLE_IN_STATE);
                result=result && true==obj.__isErrored();
                erroredFields=obj.getErroredFields();
                result=result && 1== erroredFields.length;
                var error=erroredFields[0].__getError();
                result=result && error.type=='BaseTypeException';
                result=result && error.code==Siviglia.model.BaseTypedException.ERR_NOT_EDITABLE_IN_STATE;
                thrown=true;
            }
            result=result && true==thrown;
            // Ese ultimo cambio de estado no deberia lanzar excepciones
            obj.status="Other";
            return result;
    });
    d1 = defInstance.getDefinition2();
    runTest(
        "Comprobacion de errores generados por cambios de estado",
        "Se comprueba que los errores generados por cambios de estado, se asignan correctamente a los campos que los generan.La excepcion lanzada, y la que se almacena en el objeto, es la misma (de hecho, es el mismo objeto)",
        d1
        ,
        function(def) {
            var obj= new Siviglia.model.BaseTypedObject(def);
            obj.status="Other";
            var thrown=false;
            var result=true;
            try{
                obj.status="Another";
            }
            catch(e) {
                thrown=true;
                result=result && e.type=='BaseTypeException';
                result=result && e.code===Siviglia.model.BaseTypedException.ERR_REQUIRED_FIELD;
                result=result && true==obj.__isErrored();
                var errored=obj.getErroredFields();
                result=result && 1==errored.length;
                result=result && "/three"==errored[0].__getFieldPath();
                exception=errored[0].__getError();
                result=result && exception.type=='BaseTypeException';
                result=result && exception.code==Siviglia.model.BaseTypedException.ERR_REQUIRED_FIELD;

            }
            result=result && true==thrown;
            return result;
    });
    d1 = defInstance.getDefinition2();
    runTest(
        "Comprobacion de cambio de estado ok",
        "Se comprueba que la definicion usada en los ejemplos anteriores cambia de estado de forma correcta, cuando los campos que requiere estan presentes",
        d1
        ,
        function(def) {
            var obj= new Siviglia.model.BaseTypedObject(def);
        obj.three="Test";
        obj.status="Another";
        return "Another"==obj["*status"].getLabel();
    });
    d1 = defInstance.getDefinition2();
    runTest(
        "Otra comprobacion de cambio de estado incorrecto",
        "Utilizando la misma definicion, se intenta pasar de un estado (Another) a otro (Other), que solo permite transicionar a él desde el estado None,lo que provoca la excepcion",
        d1
        ,
        function(def) {
            var obj= new Siviglia.model.BaseTypedObject(def);
            obj.three="Hola";
            obj.status="Another";
            obj.cleanDirtyFields();
            var thrown=false;
            var result=true;
            try{
                obj.status="Other";
            }catch(e) {
                thrown=true;
                result = e.type == 'BaseTypeException';
                result = result && e.code == Siviglia.model.BaseTypedException.ERR_CANT_CHANGE_STATE_TO;
            }
            return result && thrown;
    });
    /**
     * Test 10: Error al cargar datos, ya que se intenta ir a un estado
     * no posible desde el estado actual:
     */
    d1 = defInstance.getDefinition2();
    runTest(
        "Error al intentar una transicion de estado no permitida",
        "Se intenta pasar de un estado a otro, cuando esa transicion no esta permitida.",
        d1
        ,
        function(def) {
            var obj= new Siviglia.model.BaseTypedObject(def);
            obj.three="THR";
            obj.status="Another";
            obj.save();
            var result=true;
            var thrown=false;
            try {
                obj.status = "Other";
            }catch(e)
            {
                thrown=true;

                var errored=obj.getErroredFields();
                result=result && errored.length===1;

                var erroredField=errored[0];
                result=result && erroredField.__getFieldName()==="status";
            }
            return result && thrown;
    });
    d1 = defInstance.getDefinition2();
    runTest(
        "Error al cambiar a estado no definido",
        "Se intenta pasar a un estado no definido, lanzandose un error de UNKNOWN_STATE",
        d1
        ,
        function(def) {
            var obj= new Siviglia.model.BaseTypedObject(def);
            var result=true;
            var thrown=false;
            try{
                obj.status="NotExistent";
            }catch(e)
            {
                thrown=true;
                result = e.type == 'BaseTypeException';
                result = result && e.code == Siviglia.model.BaseTypedException.ERR_UNKNOWN_STATE;
            }
            return result && thrown;
    });

    var classDeclaration =
        "  \"SimpleTypedObject\": {\n" +
        "                    inherits:'Siviglia.model.BaseTypedObject',\n"+
        "                    construct:function()\n" +
        "                    {\n" +
        "                        this.__one=null;\n" +
        "                        this.__two=null;\n" +
        "                        this.__three=null;\n" +
        "                        this.__four=null;\n" +
        "                        this.__five=null;\n" +
        "                        this.__testedOk=false;\n" +
        "                        this.__testedNok=false;\n" +
        "                        this.__enteringCalled=false;\n" +
        "                    },\n" +
        "                    methods:{\n" +
        "                        check_five:function(value){if(value==\"five\")return true;return false;},\n" +
        "                        process_five:function(value){return \"six\";},\n" +
        "                        callback_one:function(){this.__one=\"one\";},\n" +
        "                        callback_two:function(){this.__two=\"set\";},\n" +
        "                        callback_three:function(){this.__three=\"three\";},\n" +
        "                        callback_four:function(){this.__four=\"four\";},\n" +
        "                        test_ok:function(){this.__testedOk=true;return true;},\n" +
        "                        test_nok:function(){this.__testedNok=true;return false;},\n" +
        "                        get_seven:function(){return \"seven\";},\n" +
        "                        check_eight:function(value){return value.length>3;},\n" +
        "                        process_eight:function(value){return value+\"##\";},\n" +
        "                        enteringState:function(){this.__enteringCalled=true;return true;}\n" +
        "                    }\n" +
        "                }";
    var classContainer = document.createElement("div");
    classContainer.className = "result";
    var classContainerTitle = document.createElement("div");
    classContainerTitle.className = "resultOk";
    classContainerTitle.innerHTML = "Clase utilizada en los tests de estado, con los callbacks definidos para test y cambio de estado";
    classContainer.appendChild(classContainerTitle);
    classShow = document.createElement("div");
    classShow.className = "testCode";
    classShow.innerHTML = "<pre>" + hljs.highlightAuto(classDeclaration).value + "</pre>";
    classContainer.appendChild(classShow);
    var classHTML=classContainer.outerHTML;

    var defInstance = new Test.Definitions();
    var d1 = defInstance.getDefinition1();


    d1 = defInstance.getDefinition4();
    runTest(
        classHTML+"Tests de llamada de callbacks",
        "Al cambiar el estado del objeto, se llaman diferentes callbacks:ON_ENTER,ON_LEAVE y TESTS.Los callbacks de TEST se llaman para verificar que el cambio de estado se permite.En la definicion usada en este ejemplo, hay un test que siempre devuelve falso, asociado al paso al estado Another. Es por eso que salta una excepcion al intentar ir a ese estado.",
        d1
        ,
        function(def) {
            var obj= new Test.SimpleTypedObject(def);
            obj.status="Other";
            var result=true;
        // Se ha abandonado el estado None, por lo que se ha tenido que ejecutar
        // el LISTENER_TAG ONE, es decir, el callback_one, y la variable __one debe valer "one".
        // Tambien se ha entrado en el estado Other, desde el estado None,
        // por lo que se ha tenido que ejecutar el LISTENER_TAG "TWO"
            result=result && "one"==obj.__one;
            result=result && "set"==obj.__two;
            result=result && null==obj.__three;
            obj.cleanDirtyFields();
        // Se pasa de "Other" a "Another": Debe fallar porque el test_nok se
        // ejecuta, y devuelve false.Se comprueba la excepcion, y que se ha
        // ejecutado el test.
            obj.three="thr";
            var thrown=false;
            try {
                obj.status="Another";

            }catch(e)
            {
                thrown=true;
                result = e.type == 'BaseTypeException';
                result = result && e.code == Siviglia.model.BaseTypedException.ERR_CANT_CHANGE_STATE;
            }
        return result && thrown;
    });
    d1 = defInstance.getDefinition4();
    runTest(
        "Segundo test de callbacks de estado",
        "Esta vez, se aplica otro callback de TEST, que en este caso retorna true, por lo que se acepta el cambio de estado.El callback de test, ademas, establece el valor de una variable. Se comprueba que esa variable ha cambiado, por lo que el callback se ha llamado.",
        d1
        ,
        function(def) {
            var obj = new Test.SimpleTypedObject(def);
            obj.status = "Other";
            obj.cleanDirtyFields();
            obj.status="None";
            var result=true;
            result=result && true==obj.__testedOk;
            return result;

        });
    d1 = defInstance.getDefinition4();
    runTest(
        "Tercer test de callbacks de estado",
        "Esta vez, se ejecuta tanto un METHOD como un PROCESS, especificados en el ON_ENTER del estado Another",
        d1
        ,
        function(def) {
            var obj = new Test.SimpleTypedObject(def);

        obj.three="thr";
        obj.status="Last";
        var result=true;
        // Se ejecuta tanto el tag THREE como el proceso P_ONE
        result=result && "three"==obj.__three;
        result=result && "one"==obj.__one;
        result=result && "set"==obj.__two;
        //Ademas, al haber entrado al estado Last, tiene que haberse ejecutado
        // el TEST_OK, por lo que __testedOk debe ser true
        result=result && true==obj.__testedOk;
        return result;
    });

    d1 = defInstance.getDefinition4();
    runTest(
        "Comprobacion de que no es posible salir de un estado final",
        "",
        d1
        ,
        function(def) {
            var obj = new Test.SimpleTypedObject(def);
            obj.three = "thr";
            obj.status = "Last";
            obj.cleanDirtyFields();
            var thrown=false;
            var result=true;
            try{
                obj.status="None";
            }catch(e)
            {
                thrown=true;
                result = e.type == 'BaseTypeException';
                result = result && e.code == Siviglia.model.BaseTypedException.ERR_CANT_CHANGE_FINAL_STATE;
            }
            return result && thrown;

        });
    d1 = defInstance.getDefinition5();
    runTest(
        "Comprobacion de callbacks especificados con *",
        "La especificacion de callbacks asociados a ENTER,LEAVE o TEST, puede ser diferente segun el estado del que se sale o al que se llega. Esos estados se pueden especificar con el nombre del estado, o con el caracter *, para cualquier otro estado que no se haya especificado.",
        d1
        ,
        function(def) {
            var obj = new Test.SimpleTypedObject(def);
            obj.three="thr";
            obj.status="Last";
            var result=true;
            // Se ha tenido que ejecutar el callback "TWO" via el estado "*"
            result=result && "set"==obj.__two;
            return result;
        });
    d1 = defInstance.getDefinition5();
    runTest(
        "Comprobacion de callbacks independientes",
        "La especificacion de callbacks asociados a ENTER,LEAVE o TEST, puede ser independiente del estado al que se llega o del que se sale",
        d1
        ,
        function(def) {
            var obj = new Test.SimpleTypedObject(def);
            obj.three="thr";
            var result=true;
            result=result && null==obj.__three;
            obj.status="Other";
            // Se ha tenido que ejecutar el callback "TWO" via el estado "*"
            result=result && "three"==obj.__three;
            return result;
        });

    d1 = defInstance.getDefinition6();
    runTest(
        "Comprobacion de path simple",
        "Simple obtencion del valor de un campo, a traves del path",
        d1
        ,
        function(def) {
            var obj = new Test.SimpleTypedObject(def);
            obj.one="str_one";
            var result=true;
            val=obj.getPath("/one");
            result=result && "str_one"==val;
            return result;
        });
    d1 = defInstance.getDefinition6();
    runTest(
        "Comprobacion de paths complejos",
        "Obtencion de valores a partir de paths, atravesando arrays y diccionarios",
        d1
        ,
        function(def) {
            var obj = new Test.SimpleTypedObject(def);
            obj.one = "str_one";
            obj.arr = ["c1", "c2"];
            obj.dict = {}
            obj.dict.c1 = "f1";
            obj.dict.c2 = ["first", "second"];
            var result=true;
            val = obj.getPath("/arr/0");
            result = result && "c1" == val;
            val2 = obj.getPath("/dict/c1");
            result = result && "f1" == val2;
            val3 = obj.getPath("/dict/c2/1");
            result = result && "second" == val3;
            return result;
        });
    d1 = defInstance.getDefinition6();
    runTest(
        "Comprobacion de paths complejos 2",
        "Obtencion de valores a partir de un path que contiene una referencia a otro campo",
        d1
        ,
        function(def) {
            var obj = new Test.SimpleTypedObject(def);
            obj.one="arr";
            obj.arr=["c1","c2"];
            var val=obj.getPath("/{%/one%}/0");
            var result=true;
            result=result && "c1"==val;
            return result;
        });
    runTest(
        "Comprobacion de paths complejos 2",
        "Obtencion de valores a partir de un path que contiene una referencia a otro campo",
        {
            "FIELDS":{
                "one":{"TYPE":"String"},
                "two":{"TYPE":"String"},
                "state":{"TYPE":"State","VALUES":["E1","E2","E3"],"DEFAULT":"E1"},
                "inner":{
                    "TYPE":"Container",
                    "REQUIRED":true,
                        "FIELDS":{
                            "one":{"TYPE":"String"},
                            "two":{"TYPE":"String"},
                            "three":{"TYPE":"String"},
                            "state":{"TYPE":"State","VALUES":["E1","E2","E3"],"DEFAULT":"E1"}
                        },
                        'STATES' : {
                            'STATES' : {
                                'E1' : {
                                    'FIELDS' : {
                                        'EDITABLE' : ['one','two','inner']
                                    }
                                },
                                'E2' : {
                                    'ALLOW_FROM':["E1"],
                                    'FIELDS' : {'EDITABLE' : ['two','three']}
                                },
                                'E3' : {
                                    'ALLOW_FROM':["E2"],
                                    'FINAL':true,
                                    'FIELDS' : {'REQUIRED' : ['three']}}
                            },
                            'FIELD' : 'state'
                        }
                    }
                },
                'STATES' : {
                    'STATES' : {
                        'E1' : {
                            'FIELDS' : {'EDITABLE' : ['one','two','inner']}
                        },
                        'E2' : {
                            'ALLOW_FROM':["E1"],
                            'FIELDS' : {'EDITABLE' : ['two','three']}
                        },
                        'E3' : {
                            'ALLOW_FROM':["E2"],
                            'FINAL':true,
                            'FIELDS' : {'REQUIRED' : ['three']}}
                    },
                    'FIELD' : 'state'
                }
            }
        ,
        function(def) {
            var t=new Siviglia.model.BaseTypedObject(def);
            // Se intenta asignar un valor no valido del container interno:
            var thrown=false;
            var result=true;
            try {
                t.setValue({"one":"aa","state":"E1","inner":{"three":"zzz","state":"E1"}});
            }catch(e)
            {
                thrown=true;
                var isErrored=t.__isErrored();
                var isErrored2=t["*inner"].__isErrored();
                var isErrored3=t.inner["*three"].__isErrored();
                result=result && isErrored && isErrored2 && isErrored3;
                var e1=t.getErroredFields();
                var path=e1[0].__getFieldPath();
                var e2=t["*inner"].getErroredFields();
                var path2=e2[0].__getFieldPath();
                result=result && "/inner"===path;
                result=result && "/inner/three"===path2;
            }
            result=result && thrown;
            // Arreglamos el campo inner:
            t.inner={"one":"qq","state":"E1"};
            var isErrored=t.__isErrored();
            var isErrored2=t["*inner"].__isErrored();

            var isErrored3=t.inner["*three"].__isErrored();

            result=result && false==( isErrored || isErrored2 || isErrored3);
            // Se pasa el inner al estado E2, y luego a E3, donde deberia dar un error, ya que three es requerido
            t.inner.state="E2";
            thrown=false;
            try {
                t.inner.state="E3";
            }catch(e)
            {
                thrown=true;
                result = e.type == 'BaseTypeException';
                result = result && e.code == Siviglia.model.BaseTypedException.ERR_REQUIRED_FIELD;
                isErrored=t.__isErrored();
                isErrored2=t["*inner"].__isErrored();
                var e1=t.getErroredFields();
                var path=e1[0].__getFieldPath();
                var e2=t["*inner"].getErroredFields();
                path2=e2[0].__getFieldPath();
                result=result && "/inner"==path;
                result=result && "/inner/three"==path2;
            }
            result=result && thrown;
            return result;
        });

    
        

    




</script>
<script>
    checkTests();
</script>
</body>
</html>
